[["index.html", "FishSimGTG: Population dynamics simulation 1 What is FishSimGTG? 1.1 Installation and required packages 1.2 How to use FishSimGTG?", " FishSimGTG: Population dynamics simulation Nature Analytics Version 1.0.7 2025-06-04 1 What is FishSimGTG? FishSimGTG is an R package that conducts numerical modeling of fish populations, including management strategy evaluation (MSE) and is an age-structured model that represents multiple concurrent cohorts using the growth-type-group methodology (Walters and Martell 2004). This framework is typically used to quantify trade-offs among competing management strategies or management options in terms of expected achievement of fishery management objectives. These trade-offs emerge from modeling results that are obtained from analysis methods like management strategy evaluation (MSE) or population dynamics projection. Calculation of trade-offs can play a meaningful role in supporting the development fishery management plans and fishery rule making. Simulations are implemented in the R statistical computing environment (R Core Team 2022). This framework is not a ‘black box’ software, and thus, it is intended to be customized to address specific questions related to fishery management. 1.1 Installation and required packages FishSimGTG is coded in R (R Core Team 2022) and requires some basic packages that can be installed as follows: Install R: Go to the CRAN website. Download and install the appropriate version of R for your operating system (Windows, macOS, or Linux). Install RStudio: Go to the RStudio website. Download and install RStudio Desktop (free version). Installing Required Packages: The user can install the necessary packages to run the simulation and visualize the outputs by using the following R commands: install.packages(&quot;devtools&quot;) library(devtools) devtools::install_github(&quot;natureanalytics-ca/fishSimGTG&quot;) devtools::install_github(&quot;natureanalytics-ca/fishSimTools&quot;) Load the Required Packages: library(fishSimGTG) library(fishSimTools) The core packages required to run the simulation are fishSimGTG and fishSimTools. The devtools package is necessary because it allows us to install these core packages directly from GitHub, ensuring we have the latest versions and updates. 1.2 How to use FishSimGTG? The FishSimGTG package can be used to construct an operating model (OM) that simulates population and fishery dynamics, including data collection and the application of user-customized management procedures. The OM consists of several S4-type objects, such as the LifeHistory object, Fishery object, and TimeArea object, etc. These objects store parameters and information in slots, which users can access using the @ symbol. This user guide provides a full description of the S4 object components and instructions on how to populate each object to create the OM. References R Core Team. 2022. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Walters, Carl J, and Steven JD Martell. 2004. Fisheries Ecology and Management. Princeton University Press. "],["om.html", "2 Description of the Operating Model (OM) 2.1 Population dynamics 2.2 Life history 2.3 Initial conditions 2.4 Fishery dynamics 2.5 Observation and monitoring 2.6 Growth-type group", " 2 Description of the Operating Model (OM)     This section describes the base configuration of the population dynamics equations used in the simulation framework. Please be aware that this configuration can be tailored to specific applications. An operating model is a mathematical representation of the biology of a fish stock, the fishery that operates on the fish stock, and ways in which the data is collected. The operating model should also include a sub-model that reflects how the management regulations are implemented and are adhered to in practice (Punt et al. 2016). 2.1 Population dynamics     The operating model (OM) describes the age-structured population dynamics of a fish population or stock. Population dynamics are specified for a single sex, with dynamics operating on an annual time step, and allowing for migration (of all age classes) between multiple areas. Abundance at age, \\(a\\), at the start of year \\(t\\), and in area \\(i\\), \\(N_{a,t,i}\\) is given by: \\[ N_{0,t,i} = \\rho_i R_t, \\tag{eq. 1} \\label{eq:first} \\] And, \\[ N_{a+1,t+1,i} = S_{a,t,i} \\left(N_{a,t,i}\\theta_{i \\rightarrow i}+\\sum_{j \\neq i} N_{a,t,j}\\theta_{j \\rightarrow i}\\right). \\tag{eq. 2} \\label{eq:second} \\] Equation \\(\\ref{eq:first}\\) is the fraction, \\(\\rho_i\\), of total age-0 recruits, \\(R_t\\), at the start of the year that are added to area \\(i\\). In equation \\(\\ref{eq:second}\\), the term in parenthesis describes the fraction of abundance-at-age that does not emigrate from area \\(i\\), \\(\\theta_{i \\rightarrow i}\\), plus the summation of abundance-at-age arriving from all other areas, \\(j\\), \\(\\theta_{a,j \\rightarrow i}\\). In this form, Equation \\(\\ref{eq:second}\\) specifies migration to occur at the beginning of the year, followed by survival, \\(S_{a,t,i}\\), from age \\(a\\) to age \\(a+1\\).     The multi-area model is implemented in matrix form, analogous to a Leslie matrix, as described by Quinn and Deriso (1999). For brevity, the matrix form is summarized using a two-area example, reflecting the description provided by Quinn and Deriso (1999), but note that the operating model is generalized as a multi-area model. To account for migration between two areas, \\(i\\) and \\(j\\), abundance-at-age in the matrix form is: \\[ \\mathbf{N}_{t+1} = \\mathbf{P}\\mathbf{N}_t, \\tag{eq. 3} \\label{eq:third} \\] where \\(\\mathbf{N}_t\\) for ages 0 to maximum age, \\(A\\), is written: \\[ \\mathbf{N}_t = \\begin{pmatrix} \\mathbf{N}_{t,i} \\\\ \\mathbf{N}_{t,j} \\end{pmatrix} = \\begin{pmatrix} N_{1,t,i} \\\\ \\vdots \\\\ N_{A,t,i} \\\\ N_{1,t,j} \\\\ \\vdots \\\\ N_{A,t,j} \\end{pmatrix}. \\tag{eq. 4} \\label{eq:fourth} \\] The projection matrix \\(\\mathbf{P}\\) is \\[ \\mathbf{P} = \\begin{pmatrix} P_{i,j} &amp; P_{i,j} \\\\ P_{i,j} &amp; P_{i,j} \\end{pmatrix}, \\tag{eq. 5} \\label{eq:fifth} \\] where each element, \\(P_{i,j}\\), is a matrix that accounts for movement and survival. The matrices, \\(P_{i,j}\\), are populated as: \\[ P_{i,i} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ S_{1,t,i}\\theta_{1,i\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_{2,t,i}\\theta_{2,i\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\ddots &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; S_{A-1,t,i}\\theta_{A-1,i\\rightarrow i} &amp; S_{A,t,i}\\theta_{A,i\\rightarrow i} \\end{pmatrix}, \\tag{eq. 6} \\label{eq:sixth} \\] And, \\[ P_{i,j} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ S_{1,t,i}\\theta_{1,j\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_{2,t,i}\\theta_{2,j\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\ddots &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; S_{A-1,t,i}\\theta_{A-1,j\\rightarrow i} &amp; S_{A,t,i}\\theta_{A,j\\rightarrow i} \\end{pmatrix}. \\tag{eq. 7} \\label{eq:seventh} \\] The operating model specifies a plus group in position (\\(A,A\\)).     Total annual recruitment is calculated according to the Beverton and Holt (1957) stock-recruitment function, which is parameterized using steepness \\((h)\\): \\[ R_t = \\left(\\frac{0.8R_0hB_t}{0.2B_0\\left(1-h\\right) + \\left(h-0.2\\right)B_t}\\right) \\exp{\\left(d_t - \\frac{{\\sigma_R}^2}{2}\\right)}, \\tag{eq. 8} \\label{eq:eighth} \\] where \\(B_0\\) is unfished reproductive output, \\(R_0\\) is unfished recruitment, and \\(d\\) is the annual recruitment deviation, where \\(\\sigma_R\\) is recruitment variability. Annual reproductive output, \\(B_t\\), is aggregate output (e.g., spawning biomass) for all areas combined, excluding any reproductive contribution of age-0 recruits created at the beginning of the year. Calculated total recruits are distributed to each area in proportion to the area-specific fraction, \\(\\rho_i\\), with \\(\\sum\\rho_i=1\\). An overall log-scale recruitment deviation signal (e.g., a surrogate for an environmental condition affecting recruitment success) is generated from a normal distribution with mean zero and standard deviation, \\(\\sigma_R\\), (e.g., \\(\\sigma_R\\) = 0.6). Inter-annual autocorrelation in recruitment can be specified, producing 1-year lagged correlation in log-scale recruitment deviations. 2.2 Life history     Length is calculated at the start of the year according to the von Bertalanffy growth curve, where \\(L_\\infty\\) is asymptotic length, \\(K\\) is the growth rate, and parameter \\(t_0\\): \\[ L_a = L_\\infty \\left(1- \\exp{\\left(-K\\left(a - t_0\\right)\\right)}\\right). \\tag{eq. 9} \\label{eq:nineth} \\] Weight-at-age, \\(W_a\\), with parameters \\(a\\) and \\(b\\) is specified as an exponential function: \\[ W_a=\\alpha L_a^\\beta. \\tag{eq. 10} \\label{eq:tenth} \\] Maturation follows a logistic function with parameters \\(L50\\) and \\(L95\\), reflecting the lengths at which 50% and 95% of the population are mature, respectively. Optionally, species can be specified as protogynous hermaphroditic species, with proportion of male in the population following an increasing logistic function with parameters \\(H50\\) and \\(H95\\), reflecting the lengths at which 50% and 95% of the population are male, respectively. For gonochoristic species, a 50:50 sex ratio is assumed at all lengths or ages. Total reproductive output, \\(B_t\\), is a summation of mature biomass across age classes and areas: \\[ B_t=\\sum_{i}\\sum_{a}{N_{a,t,i}W_a\\mathit{mat}_a{propFemale}_a}, \\tag{eq. 11} \\label{eq:eleventh} \\] Where \\(propFemale\\) is proportion of the population female at age, with a value of 0.5 for all ages for gonochoristic species and values of 1-\\(propMale_a\\) when sexual transition from female to male is specified.     Both natural mortality and maximum age can be specified. When maximum age, \\(A\\), is specified, this quantity is used in constructing abundance matrices. Maximum must be equal to or greater than 2, as this modeling framework is not well suiting to species with very fast life histories. When maximum age is not specified, the age to which 1% the population survives in an unfished system is used to calculate maximum age, using the formula: \\[ A=\\ ceiling\\left(-\\frac{\\log{\\left(0.01\\right)}}{M}\\right) \\tag{eq. 12} \\label{eq:twelftth} \\] Uncertainty in life history can be accounted for by specifying parameter ranges, rather than point estimates for most life history parameters. Each iteration will produce a unique set of life history parameters based on independent draws from uniform distributions that correspond to the specified minimum and maximum for each parameter. 2.3 Initial conditions     This modeling framework was developed to create historical dynamics of fish stocks that begin (i.e., year 0) in a fished state, meaning that fishing mortality (and consequently fishing effort) are greater than zero in the initial equilibrium year (year 0). Thus, the modeling framework is not suitable for circumstances for initializing the model in an unfished or pre-fishing state. Accordingly, initial depletion (spawning biomass relative to unfished spawning biomass) should always be less than 1.0. An alternative formulation is available where initial ‘depletion’ can instead be specified as initial Spawning Potential Ratio (SPR). SPR is spawning biomass per recruit relative to unfished spawning biomass per recruit). Subsequently, the population is initialized as follows. First, equilibrium age-structure is determined for the given depletion or SPR level assuming area-specific recruitment fractions, \\(\\rho_i\\), but no movement, resulting in an equilibrium fishing mortality rate and equilibrium abundance scaled relative to the specified \\(R_0\\). Second, a burn-in period is used to project the population forward for \\(A\\)x4 years at the estimated equilibrium fishing mortality rate, allowing a stable age distribution between areas to be obtained through migration. 2.4 Fishery dynamics     Survival (\\(S\\)) consists of natural mortality (\\(M\\) year\\(^{-1}\\), fishing mortality (\\(F\\) year\\(^{-1}\\)): \\[ S_{a,t,i}=exp{\\left(-M-{\\mathit{Removal}}_aF_{t,i}\\right)}, \\tag{eq. 13} \\label{eq:thirteenth} \\] where \\(Removal\\) is a component of fishery selectivity and is covered in a subsequent section. Landings in numbers (\\(C^{N}\\) is: \\[ C_{a,t,i}^N=\\frac{{\\mathit{Keep}}_aF_{t,i}}{\\left(M_s+{\\mathit{Removal}}_aF_{t,i}\\right)}\\left(1-S_{a,t,i}\\right)N_{a,t,i}, \\tag{eq. 14} \\label{eq:fourteenth} \\] and \\(keep\\) is a component of fishery selectivity. Landings in weight (\\(C^B\\)) is: \\[ C_{a,t,i}^B=C_{a,t,i}^NW_a \\tag{eq. 15} \\label{eq:fifteenth} \\] Fishery selectivity is defined as follows. Vulnerability to the fishing gear includes several options. Retention, \\(Ret\\), can be specified as ‘full’, resulting in full retention across all vulnerable size classes, ‘logistic’ or ‘slot limit’. Additionally, the maximum level of retention (e.g., a quantity between 0 and 1) can be specified for any of the above stated retention types. Finally, a discard mortality proportion, \\(D\\), (e.g. quantity between 0 and 1) can be specified to affect the fate of discards. These inputs are used in calculating the following components of fishery selectivity. Note: vulnerability and retention are specified as functions of length. These components of fishery selectivity are converted to age using corresponding length-at-age. \\(Keep\\) - the resulting probability of being landed \\[ Keep_a=Vul_aRet_a \\tag{eq. 16} \\label{eq:sixteenth} \\] \\(Dead\\,discards\\) - deaths resulting from vulnerable abundance that is not retained \\[ Dead\\,discards_a=Vul_a(1-Ret_a)D \\tag{eq. 17} \\label{eq:seventeenth} \\] \\(Total\\,removals\\) – probability of removal from the population via landing or discard \\[ Removal_a=Vul_a(Ret_a+(1-Ret_a)D) \\tag{eq. 18} \\label{eq:eighteenth} \\] Uncertainty in vulnerability and retention can be accounted for by specifying parameter ranges, rather than point estimates. Each iteration will produce a unique selectivity and/or retention characteristics based on independent draws from uniform distributions that correspond to the specified minimum and maximum for each parameter. 2.5 Observation and monitoring     Depending on the specific application of the model, an observation model may be required. This requirement is driven by whether a harvest control rule is used in decision-making. That is, whether some form of data collection will inform year-to-year adjustments in a total allowable catch or total fishery effort. If so, then simulation of the data observation processes (including imperfect observation) is required. Observation models tend to be tailored to the type of data collection program that is in place. This component should be developed as needed for each unique application. 2.6 Growth-type group To account for individual variation in growth trajectories, the population is divided into growth-type groups (GTGs) or cohorts Hordyk et al. (2016). GTGs describe the variation in growth of a fish population through the creation of \\(G\\) groups and with dimensions indexed \\(g=1,2…G\\). Each group differs in terms of its \\(L_\\infty\\). Given a mean value, \\(\\bar{L}_\\infty\\) and a standard deviation (calculated as a coefficient of variation, \\(CV_L\\) times \\(\\bar{L}_\\infty\\)), the range of \\(L_\\infty\\) ± two standard deviations is divided into \\(G\\) equal increments. A default value of \\(CV_L\\) = 0.1 and \\(G\\) = 13 groups, results in \\(g\\) = 7 representing \\(\\bar{L}_\\infty\\). Cohort size assigned to each group is determined by distributing a fraction of annual recruits in each group, \\(p\\), where \\(\\sum{p}=1\\). Vector \\(p\\) is determined as proportional to the \\(G\\) increments in \\(L_\\infty\\) along the probability density function of a normal distribution with mean \\(\\bar{L}_\\infty\\) and variance \\(\\left(CV_L{\\bar{L}}_\\infty\\right)^2\\). Functionality is also included such that if \\(G\\) = 1, the model collapses to a simpler age-based model. References Beverton, R. J. H., and S. J. Holt. 1957. On the Dynamics of Exploited Fish Populations. London: Her Majesty’s Stationery Office. Hordyk, Adrian R., Kotaro Ono, Jeremy D. Prince, and Carl J. Walters. 2016. “A Simple Length-Structured Model Based on Life History Ratios and Incorporating Size-Dependent Selectivity: Application to Spawning Potential Ratios for Data-Poor Stocks.” Canadian Journal of Fisheries and Aquatic Sciences 73 (12): 1787–99. https://doi.org/10.1139/cjfas-2015-0422. Punt, André E., Doug S. Butterworth, Carryn L. de Moor, José A. A. De Oliveira, and Malcolm Haddon. 2016. “Management Strategy Evaluation: Best Practices.” Fish and Fisheries 17 (2): 303–34. https://doi.org/10.1111/faf.12104. Quinn, Terrance J, and Richard B Deriso. 1999. Quantitative Fish Dynamics. oxford university Press. "],["om-pop.html", "3 Parameters of the Operating Model (OM) 3.1 Time area object 3.2 Life history object 3.3 Historical fishery object 3.4 Stochastic object 3.5 Simulating historical dynamics", " 3 Parameters of the Operating Model (OM) The OM is comprised of three required objects in S4 format: Life history object (LifeHistoryObj) Historical fishery object (HistFisheryObj) Time-area object (TimeAreaObj) Optional: Stochastic object (StochasticObj) Each of these S4 objects contains a specific number of slots, which can be accessed using the slotNames() function. These slots are populated within R. The simplest way to start building the OM is to create a new object using the R function new() and populate it with the required input information and parameters. The first step, before populating the slots of each object, is to create a new object using the new() function. 3.1 Time area object The TimeAreaObj object holds temporal and spatial elements of the operating model, including descriptions of time steps, growth-type groups (GTGs), and spatial area parameters. The FishSimGTG package allows the user to model migration between multiple areas. To create a new object of class TimeArea, use the new() function as follows: TimeAreaObj&lt;-new(&quot;TimeArea&quot;) To populate the slots of the TimeAreaObj object, the user should start by defining a meaningful title (title). Similar to the other S4 objects, the slot names of the TimeAreaObj can be viewed using the slotNames() function, and the user can access the help file using the ? symbol. slotNames(TimeAreaObj) ## [1] &quot;title&quot; &quot;gtg&quot; &quot;areas&quot; ## [4] &quot;recArea&quot; &quot;move&quot; &quot;iterations&quot; ## [7] &quot;historicalYears&quot; &quot;historicalBio&quot; &quot;historicalBioType&quot; ## [10] &quot;historicalEffort&quot; #getting help ?`TimeArea-class` TimeAreaObj@title = &quot;Test&quot; TimeAreaObj@gtg = 13 TimeAreaObj@areas = 2 TimeAreaObj@recArea = c(0.99, 0.01) TimeAreaObj@iterations = 100 TimeAreaObj@historicalYears = 10 TimeAreaObj@historicalBio = 0.5 TimeAreaObj@historicalBioType = &quot;relB&quot; TimeAreaObj@move &lt;- matrix(c(1,0, 0,1), nrow=2, ncol=2, byrow=FALSE) TimeAreaObj@historicalEffort&lt;-matrix(1:1, nrow = 10, ncol = 2, byrow = FALSE) The FishSimGTG package allows for accounting for individual variation in growth trajectories by dividing the population into growth-type groups (GTGs), so each age class is divided into a collection of smaller cohorts or GTGs. The gtg slot in TimeAreaObj represents the number of growth-type groups, with a default value of 13. areas represents the number of areas in the model, and it must be greater than 1, even when a single-area model is desired. recArea is a vector of length areas. Each element of the vector represents the fraction of recruitment to each area, with the values summing to 1. In this example, 0.99 of the recruitment is assigned to area 1, and 0.01 to area 2, implying that the model is treated similarly to a single-area model. iterations is the number of iterations to run (i.e., the number of simulations). historicalYears are the number of years to simulate historical dynamics. historicalBio is a value grater than 0 and less than 1. The model assumes the population does not start in unfished conditions. historicalBioTypeis a string, that represents the type of historical biomass state. The options are: “relB” (relative spawning biomass) or “SPR” (Spawning Potential Ratio). move is a matrix of migration rates of dimensions areas x areas. historicalEffort is a matrix of nrows = historicalYears and ncols = areas that contains value multipiers of initial equilibrium fishing mortality. In its current form, FishSimGTG is specified such that fishing mortality rate is proportional to fishing effort. Thus, where historical patterns of fishing effort are available, these can be re-scaled as multipliers of the initial equilibrium fishing mortality. 3.2 Life history object The LifeHistoryObj is an S4 object of the class LifeHistory that holds the description of a life history. To create a new object of class LifeHistory, use the new() function, as follows: LifeHistoryObj &lt;- new(&quot;LifeHistory&quot;) The user can see the elements or slots of the LifeHistoryObject using the slotNames() function. slotNames(LifeHistoryObj) ## [1] &quot;title&quot; &quot;speciesName&quot; &quot;shortDescription&quot; &quot;L_type&quot; ## [5] &quot;L_units&quot; &quot;Walpha_units&quot; &quot;Linf&quot; &quot;K&quot; ## [9] &quot;t0&quot; &quot;L50&quot; &quot;L95delta&quot; &quot;M&quot; ## [13] &quot;MK&quot; &quot;LW_A&quot; &quot;LW_B&quot; &quot;Tmax&quot; ## [17] &quot;Steep&quot; &quot;R0&quot; &quot;recSD&quot; &quot;recRho&quot; ## [21] &quot;isHermaph&quot; &quot;H50&quot; &quot;H95delta&quot; The user can access the help file for classes by using ? symbol ?`LifeHistory-class` In the help file, the user will find a description of the LifeHistoryObject and the elements or slots it contains. To populate the rest of the slots of the LifeHistoryObject, the user should start by defining a useful title (title), followed by the scientific name of the species (speciesName). If desired, the user can add a short description (shortDescription) of the object. LifeHistoryObj@title&lt;-&quot;Kole&quot; LifeHistoryObj@speciesName&lt;-&quot;Ctenochaetus strigosus&quot; LifeHistoryObj@shortDescription&lt;-&quot;stock name/location&quot; Then, the user can proceed to populate the rest of the slots as follows: LifeHistoryObj@Linf&lt;-17.7 LifeHistoryObj@K&lt;-0.423 LifeHistoryObj@t0&lt;- -0.51 LifeHistoryObj@L50&lt;-8.4 LifeHistoryObj@L95delta&lt;-1.26 LifeHistoryObj@M&lt;-0.08 LifeHistoryObj@L_type&lt;-&quot;FL&quot; LifeHistoryObj@L_units&lt;-&quot;cm&quot; LifeHistoryObj@LW_A&lt;-0.046 LifeHistoryObj@LW_B&lt;-2.85 LifeHistoryObj@Steep&lt;-0.54 LifeHistoryObj@recSD&lt;-0 LifeHistoryObj@recRho&lt;-0 LifeHistoryObj@isHermaph&lt;-FALSE LifeHistoryObj@R0&lt;-10000 Growth is modeled in the FishSimGTG package using a von Bertalanffy growth curve, where Linf represents the asymptotic length, K the Brody growth rate coefficient (with units in yr\\(^{-1}\\)), and t0 represents the time or age when the average length was zero. Maturity parameters are represented by the L50 and L95delta parameters, assuming that maturity is size-dependent and follows a logistic model. The L50 is the length at 50% maturity, and the L95delta is the length increment between L50 and the length at 95% maturity. L95delta must be a value larger than 0. M, represent the natural mortality rate per year. L_type represents the method of measuring length. e.g. \"TL\" for total length or \"FL\" for fork length. Must be consistent for all length parameters (e.g., Linf, L50, L95delta). L_units, are the units of measure (\"cm\" is expected). L_units must be consistent for all length parameters (e.g., Linf, L50, L95delta). LW_A and LW_B are the parameters of the allometric length-weight relationship. Walpha_units (help file-W_units)represents the measurement units of weight and must be consistent with the LW_A and LW_B parameters. Recruitment is modeled using a Beverton-Holt stock-recruitment relationship, parameterized in terms of steepness (Steep). Values for Steep range between &gt;0.2 to 1. R0 represents the initial number of unfished recruits (positive number). Recruitment process error is generated from a normal distribution with mean zero and standard deviation represented by recSD. Autocorrelation in recruitment deviations in log space are defined by recRho, producing 1-year lagged correlation. recSD and recRho, are non-negative real numbers. The FishSimGTG package allows for modeling the population dynamics of gonochoristic and protogynous hermaphroditic species. The user will set isHermaph to TRUE when the species is a protogynous hermaphrodite and to FALSE when it is a gonochoristic species. If the species is a protogynous hermaphrodite, the user will need to define two additional parameters: H50 and H95delta. H50 represents the length at which 50% of the population are male, and H95delta represents the length increment between H50 and length at which 95% of the population are male. H95delta must be a value larger than 0. MK and Tmax are optional parameters. MK represents the M/K ratio (natural mortality divided by von Bertalanffy K coefficient) and is not utilized by FishSimGTG; however, sister R packages such as fishLengthAssess can utilize this parameter as part of length-based stock assessment. To utilize functionality within FishSimGTG, M and K should be specified in separate slots. Tmax is the maximum observed age that defines the plus-group in modeling population dynamics. When Tmax is not specified (the default), the age to which 1% the population survives in an unfished system is used to calculate Tmax. When Tmax is specified, it must take on a quantity equal to or greater than 2. The FishSimGTG package includes several plotting functions that allow users to explore the simulated life history before proceeding to analysis. The life history schedules can be plotted using the LHwrapper() function. This function displays the plot in the console and also returns all the details of the life history. The user can access the help file for the LHwrapper() function by using the ? symbol (?LHwrapper). #To simply display to the console lhOut&lt;-LHwrapper(LifeHistoryObj, TimeAreaObj, doPlot = TRUE) Figure 3.1: Life history schedules. The upper panels represent the von Bertalanffy growth curve (left) and the maturity ogive (right). The bottom panels represent the weight-at-age relationship and the allometric length-weight relationship. lhOut returns all the details of the life history. #To return life history details lhOut 3.3 Historical fishery object The HistFisheryObj is an S4 object of the class Fishery that holds fishery characteristics, including vulnerability, retention, and discard information. In its current form, FishSimGTG is specified such that the characteristics defined in the HistFisheryObj apply to all areas. Doing so enables rapid calculation of initial stable age distribution within each area. This structure should be interpreted as the state of the resource prior to any spatial management, or alternatively, as homogeneous fishery characteristics across all areas. To create a new object of class Fishery, use the new() function, as follows: HistFisheryObj&lt;-new(&quot;Fishery&quot;) The slot names of the HistFisheryObj can be seen using the slotNames() function. slotNames(HistFisheryObj) ## [1] &quot;title&quot; &quot;vulType&quot; &quot;vulParams&quot; &quot;retType&quot; &quot;retParams&quot; &quot;retMax&quot; ## [7] &quot;Dmort&quot; The user can access the help file using ? symbol ?`Fishery-class` In the help file, the user will find a description of the HistFisheryObj and the elements or slots it contains. To populate the slots, the user should start by defining a meaningful title (title), followed by specifying the selectivity/vulnerability, retention, and discard information. HistFisheryObj@title&lt;-&quot;Test&quot; HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(10.2,0.1) #Approx. knife edge HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 3.3.1 Selectivity Selectivity or vulnerability is the probability of being selected or becoming vulnerable to the fishing gear. In the FishSimGTG package, selectivity is defined with respect to length, with a maximum value of 1 enforced. vulType describes the type of selectivity/vulnerability function for the historical time period. The user can see a detailed description of the different selectivity functions by exploring the ?selWrapper function. Common vulnerability types: “logistic” selectivity with two parameters (vulParams) represented by the length at 50% of selectivity and the length increment between the length at 50% of selectivity and the length at 95% selectivity. “explog” is an exponential logistic selectivity (dome-shaped) function, defined by three parameters (vulParams), represented as c(p1, peak, and p3). To use the “explog” function, the user must first provide the ascending rate (p1), which should be within the range of 0.02 to 1. Next, the user needs to define the peak of the vulnerability function, which corresponds to the location of the peak of the dome-shaped selectivity curve or the length at which selectivity is highest. As an aside, this peak is used to calculate p2, which determines the position of the peak relative to the range of lengths. For example, if the length range is between 1 and 20 cm, and p2 is set to 0.5, the peak will be at 10 cm. Given p2, the peak can be calculated using the following equation: \\[ \\text{peak} = \\text{min}(\\text{Length}) + p_2 \\times (\\text{max}(\\text{Length}) - \\text{min}(\\text{Length})) \\] p2 must be within the range of 0.01 to 0.9, with a reasonable starting value of 0.5. By adjusting p2, the user can shift the peak along the length range, from the minimum length to the maximum length. Finally, the user must provide p3, which is the descending rate, and which must be within the range of 0.001 to 0.5. A value of 0.001 provides a nearly asymptotic curve, while values above 0.2 produce a strongly dome-shaped function, where the p3 and p1 parameters interact strongly. 3.3.2 Retention Retention is the probability of being retained (kept by the fleet) and not discarded. It describes both the shape with respect to length and the maximum value, which can be less than 1. Fish that are selected by the fishing gear but not retained are discarded (discard mortality rate). The probability of being landed (keep), is calculated as Vulnerability × Retention. The user can see a detailed description of the different retention types by exploring the ?selWrapper function. There are three retention types (retType): “full” retention assumes that keep is equal to retention. There are no parameters (retParams) for “full” retention. “logistic” retention has two parameters (retParams): the length at 50% retention and the length increment to 95% retention. “slotLimit” retention includes two parameters (retParams): minimum length and maximum length, where catches occur between the minimum and maximum values. retMax is a numeric value between 0 and 1 that defines the peak of the retention curve. 3.3.3 Discard mortality rate Discard mortality rate represents the fish that are selected but not retained, and are therefore subject to the discard mortality rate (Dmort). Dmort is the fraction of discards that are killed (e.g., 0.25 means 25% are killed). This value must be between 0 and 1. 3.3.4 Fishery plots The FishSimGTG package includes several plotting functions that allow users to explore the simulated Vulnerability, retention, keep, dead discards, and removals at length. Fishery characteristics can be plotted using the selWrapper() function. This function displays the plot in the console. The user can access the help file for the selWrapper() function by using the ? symbol (?selWrapper). selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.2: Logistic selectivity function. selOut returns all the details of the fishery selectivity. #To return sel details selOut If the user modifies the vulnerability, retention, and discard parameters in the HistFisheryObj, other selectivity/vulnerability and retention shapes can be explored. For example: – Assuming a vulnerability type vulType of “explog”, with parameters p1, peak, and p3. HistFisheryObj@vulType&lt;-&quot;explog&quot; HistFisheryObj@vulParams&lt;-c(0.9,10,0.15) #dome-shaped HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.3: Exponential logistic selectivity (dome-shaped). – Assuming a vulnerability type vulType of “logistic”, with changes in the retention type (retType) and retention parameters (retParams). HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(10.2,0.1) #Approx. knife edge HistFisheryObj@retType&lt;-&quot;logistic&quot; HistFisheryObj@retParams&lt;-c(11,0.8) HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.4: Logistic selectivity function with different retention parameters. 3.4 Stochastic object The StochasticObj is used as a catch-all object for specifying magnitude of variation in input parameters, in two ways. Its first usage, and technically poor use of the term ‘stochastic’, is to represent a modeling approach that accounts for uncertainty in various input parameters (e.g., initial depletion, life history, selectivity, and annual recruitment deviations). Its second usage is to represent inter-annual variation (not yet implemented, except for recruitment deviations that are specified within a LifeHistoryObject). The StochasticObj holds the parameters for characterizing uncertainty about population and fishery dynamics. To create a new object of class Stochastic, use the new() function. StochasticObj&lt;-new(&quot;Stochastic&quot;) Similar to other S4 objects, the slot names of StochasticObj can be viewed using the slotNames() function, and the help file can be accessed using the ? symbol. slotNames(StochasticObj) ## [1] &quot;title&quot; &quot;historicalBio&quot; &quot;Linf&quot; ## [4] &quot;K&quot; &quot;L50&quot; &quot;L95delta&quot; ## [7] &quot;M&quot; &quot;Steep&quot; &quot;recSD&quot; ## [10] &quot;recRho&quot; &quot;H50&quot; &quot;H95delta&quot; ## [13] &quot;histFisheryVul&quot; &quot;proFisheryVul_list&quot; &quot;sameFisheryVul&quot; ## [16] &quot;histFisheryRet&quot; &quot;proFisheryRet_list&quot; &quot;sameFisheryRet&quot; ## [19] &quot;histFisheryDmort&quot; &quot;proFisheryDmort_list&quot; &quot;sameFisheryDmort&quot; #getting help ?`Stochastic-class` To populate the slots of StochasticObj, the user should begin by defining a meaningful title (title) and specifying the parameters in which they want to include variation. The slots defined in the StochasticObj object create additional inputs and override parameters specified elsewhere (e.g., LifeHistoryObj, HistFisheryObj, or TimeAreaObj), allowing the corresponding model components to become random processes. Values for these components are generated ahead of simulation and retained to ensure reproducibility of results. See documentation of runProjection() for details. In the following example, we add uncertainty to historicalBio. As state of depletion can be uncertain, initial depletion can be implemented as a range of plausible values, producing slightly different values for each iteration. This is achieved by assignubg a vector of length 2 that contains the lower and upper bounds of a uniform distribution to the slot StochasticObj@historicalBio. Doing so will override (replace) the quantity defined in the TimeAreaObj object (TimeArea@historicalBio). For each iteration, one value is drawn from a uniform distribution. Importantly, TimeArea@historicalBioType continues to determine the type of historical biomass state (e.g., ‘relB’ or ‘SPR’). StochasticObj@title&lt;-&quot;adding unceratinty&quot; StochasticObj@historicalBio = c(0.3, 0.6) 3.4.1 Uncertainty in life history All scalar parameters in the LifeHistoryObj object that hold a single value, such as Linf, K, L50, L95delta, M, Steep, recSD, recRho, H50, and H95delta, can be redefined in the StochasticObj object. When redefined, they are replaced by a vector of length 2 containing the minimum and maximum values. If provided, these values override those in the LifeHistoryObj, and a unique value for each iteration is generated by sampling from the uniform distribution. StochasticObj@Steep = c(0.5, 0.6) #e.g., adding stochasticity to Steepness 3.4.2 Uncertainty in the historical fishery A matrix with \\(n\\) columns and 2 rows is used to define the range of uncertainty for the vulnerability (vulParams) and retention (retParams) parameters from the HistFisheryObj in the StochasticObj object. Row 1 contains the minimum values, and row 2 contains the maximum values for each parameter, corresponding to the respective column \\(n\\). When this matrix is provided in the StochasticObj object, it replaces the vulParams and retParams slots previously defined in the HistFisheryObj. This ensures that the columns of the matrix align with the required inputs for vulType and retType in the HistFisheryObj object. The same logic applies to redefining the Dmort parameter, but in this case, the matrix contains only 1 column and 2 rows (min and max), as the Dmort parameter is a scalar. When this matrix is provided, it replaces the Dmort slot in the HistFisheryObj. #just to continue with the original configuration of sel and retention HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(10.2,0.1) #Approx. knife edge HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 StochasticObj@histFisheryVul=matrix(c(9,11,0.07,0.13), nrow=2, ncol=2,byrow=FALSE) #e.g., adding stochasticity to histFisheryVul There are additional slots in the StochasticObj object that modify fishery projections (ProFisheryObj), which will be described in detail in a separate section. 3.5 Simulating historical dynamics Coming soon… "],["management-procedures-mps.html", "4 Management Procedures (MPs) 4.1 Strategy object 4.2 Projection fishery object 4.3 Projection Modeling 4.4 Running the projection and management strategy simulation 4.5 Customized Management Procedures (MPs)", " 4 Management Procedures (MPs) A Management Procedure (MP) is a pre-agreed process defining how a fishery will be managed, with the primary role being to take fishery information and return a management recommendation. One of the most distinctive features of FishSimGTG is that it allows the user to create customized MPs. The FishSimGTG package can be used to make forward-projections for a variety of fishery management actions. Making forward projections requires the following set of S4-type objects. As previously discussed, the OM is comprised of three required objects in S4 format: Life history object (LifeHistoryObj) Historical fishery object (HistFisheryObj) Time-area object (TimeAreaObj) With optional: Stochastic object (StochasticObj) And, producing forward-simulation requires two additional objects in S4 format: Management procedure or harvest strategy object (StrategyObj) Projection time period fishery object (ProFisheryObj) 4.1 Strategy object The StrategyObj holds a set of instructions about how the fishery will be managed. To create a new object of class StrategyObj, use the new() function. StrategyObj&lt;-new(&quot;Strategy&quot;) The user can see the elements or slots of the StrategyObj using the slotNames() function. slotNames(StrategyObj) ## [1] &quot;title&quot; &quot;projectionYears&quot; &quot;projectionName&quot; &quot;projectionParams&quot; To populate the StrategyObj, the user should start by specifying a title (title) and the number of forward projection years to simulate (projectionYears). The projectionName is a string that directs to a named function that contains a set of instructions about how the fishery will be managed. And, projectionParams is a list of input parameters that follows the specifications of the projection function defined in projectionName. Developing the necessary code to create a custom StrategyObj can be very challenging. A StrategyObj can take the form of a simple projections or an MP. A simple projection differs from an MP in that projections consist of ‘static’ actions such as a size limit or constant fishing effort, whereas MPs are ‘dynamic’ actions such as annual adjustments to catch limits. MPs tend to be more complicated because they include a harvest control rule or decision-rule that is informed by updated information gathered from monitoring. In subsequent sections of this chapter, we will build example MPs. The user is advised to first explore Projection Modeling, in which simple projections are demonstrated using built-in functions. Understanding simple projections is a useful pre-cursor to understanding how to design and implement code for more complex MPs. 4.2 Projection fishery object The ProFisheryObj is an S4 object of the class Fishery that holds fishery characteristics, including vulnerability, retention, and discard information. Note that both the HistFisheryObj and ProFisheryObj utilize the same S4 object class. HistFisheryObj and ProFisheryObj are both Fishery objects. When no changes in the fishery characteristics are anticipated, the slots of ProFisheryObj can be set to the same values as those in HistFisheryObj ProFisheryObj&lt;-HistFisheryObj Alternatively, the user has the option to modify the HistFisheryObj object when performing fishery projections. These modifications are stored in a new ProFisheryObj. To create a new object of class Fishery, use the new() function, as follows: ProFisheryObj&lt;-new(&quot;Fishery&quot;) The slot names of the ProFisheryObj can be seen using the slotNames() function. slotNames(ProFisheryObj) ## [1] &quot;title&quot; &quot;vulType&quot; &quot;vulParams&quot; &quot;retType&quot; &quot;retParams&quot; &quot;retMax&quot; ## [7] &quot;Dmort&quot; The user can access the help file using ? symbol ?`Fishery-class` ProFisheryObj can be populated as follows: ProFisheryObj@title&lt;-&quot;Test&quot; ProFisheryObj@vulType&lt;-&quot;logistic&quot; ProFisheryObj@vulParams&lt;-c(10.2,0.1) ProFisheryObj@retType&lt;-&quot;logistic&quot; ProFisheryObj@retParams &lt;- c(15, 0.1) ProFisheryObj@retMax &lt;- 1 ProFisheryObj@Dmort &lt;- 0 In this example, during the projections, we maintain the same vulnerability type and parameters as in the HistFisheryObj object but modify retention to follow a logistic function. 4.2.1 Fishery spatial considerations Coming soon… 4.2.2 Uncertainty in the projection fishery Additional slots in the StochasticObj object allow for modifications to the fishery projection object. These additional slots, proFisheryVul_list, proFisheryRet_list, and proFisheryDmort_list, are lists where the number of list items corresponds to the number of areas (TimeAreaObj@areas). Each item in the list is a matrix with \\(n\\) columns and 2 rows, where the rows represent the minimum and maximum values for the parameters associated with each column \\(n\\). When provided, these lists replace the vulParams, retParams, and Dmort slots in the fishery projections (ProFisheryObj). For proFisheryVul_list and proFisheryRet_list, the number of columns in the matrix align with the required inputs for ProFisheryObj@vulType and ProFisheryObj@retType. During each iteration, the model samples values from a uniform distribution within the specified range (i.e., between the min and max values defined in the rows), allowing for uncertainty in the parameters, independently for each area. The final slots in the StochasticObj object are sameFisheryVul, sameFisheryRet, and sameFisheryDmort. Each slot contains a logical variable (“TRUE” or “FALSE”). If set to TRUE, the arguments of StochasticObj specified to replace arguments of the HistFisheryObj will also replace arguments of the ProFisheryObj. This option is provided so that, for a given iteration, identical values will be applied to both the historical and projection time periods. When StochasticObj@sameFisheryVul = TRUE, values generated for histFisheryVul should be applied so that historical and projection parameter values are identical. TRUE also overrides any input in proFisheryVul_list When StochasticObj@sameFisheryRet = TRUE, values generated for histFisheryRet should be applied so that historical and projection parameter values are identical. TRUE also overrides any input in proFisheryRet_list When StochasticObj@sameFisheryDmort = TRUE, values generated for histFisheryDmort should be applied so that historical and projection parameter values are identical. TRUE also overrides any input in proFisheryDmort_list 4.3 Projection Modeling In this section, we examine simple projection of a static management action (e.g., constant fishing effort). In this example, projectionParams is a list with four items. The first item is a vector of length areas containing bag limits (bag). To indicate no bag limit, use -99. The bag limit should be considered as the take per unit time (e.g., per day) and basically acts like a CPUE threshold. The second item is a matrix with nrows = projectionYears and ncols = areas that contains value multipliers of the initial equilibrium fishing effort (effort). This allows for the projection of effort reductions and the establishment of marine reserves by setting effort to 0. The two final items are a vector of length areas containing CPUE (CPUE), along with a CPUEtype, which is defined as a character string (e.g., retN for retention in numbers). StrategyObj@projectionYears &lt;- 50 StrategyObj@projectionName&lt;-&quot;projectionStrategy&quot; StrategyObj@projectionParams&lt;-list(bag = c(5, 5), effort = matrix(1:1, nrow=50, ncol=2, byrow = FALSE), CPUE = c(7,11), CPUEtype = &#39;retN&#39;) 4.4 Running the projection and management strategy simulation This section provides an example for the user on how to run projections using three management strategies that combine minimum size and bag limits. #Batch processing - 3 management strategies stateLmin&lt;-c(10.2, 12.7, 12.7) stateBag&lt;-c(20, -99, 20) fileLabel&lt;-c(&quot;Higher_option1&quot;, &quot;Higher_option2&quot;, &quot;Higher_option3&quot;) projectionLabel&lt;-c(&quot;Bag 20&quot;, &quot;Min size 5 inch&quot;, &quot;Bag 20 &amp; min size 5 inch&quot;) In this example, stateLmin is a vector containing three minimum sizes, and stateBag is a vector that contains three bag limits. To indicate no bag limit, use -99. fileLabel is a label for the file name, and projectionLabel defines the name for the strategy that will be evaluated. To run the projection under the three different management strategies (i.e., “Bag 20”, “Min size 5 inch”, and “Bag 20 &amp; Min size 5 inch”), we will use the runProjection(). In this example, we modify the retention parameters of the logistic function previously defined in ProFisheryObj@retParams. These parameters are now redefined as ProFisheryObj@retParams &lt;- c(stateLmin[sc], 0.1), using the pre-specified size limits (stateLmin). Additionally, in the list structure of the StrategyObj@projectionParams, the elements of the bag vector are replaced by the specified bag limits (stateBag). for(sc in 1:NROW(stateLmin)){ #Size limit - changes retention, not selectivity ProFisheryObj@retParams&lt;-c(stateLmin[sc],0.1) #Bag limit StrategyObj@projectionParams&lt;-list(bag = c(stateBag[sc], stateBag[sc]), effort = matrix(1:1, nrow=50, ncol=2, byrow = FALSE), CPUE = c(7,11), CPUEtype = &#39;retN&#39;) runProjection(LifeHistoryObj = LifeHistoryObj, TimeAreaObj = TimeAreaObj, HistFisheryObj = HistFisheryObj, ProFisheryObj_list = list(ProFisheryObj, ProFisheryObj), StrategyObj = StrategyObj, StochasticObj = StochasticObj, wd = here(&quot;data-test&quot;, &quot;Kole&quot;), fileName = fileLabel[sc], doPlot = TRUE, titleStrategy = projectionLabel[sc] ) } The runProjection() function contains several arguments. The objects LifeHistoryObj, TimeAreaObj, HistFisheryObj, ProFisheryObj_list, and StrategyObj were defined above. Among these, LifeHistoryObj, TimeAreaObj, and HistFisheryObj are required. The objects StochasticObj, ProFisheryObj_list, and StrategyObj are optional; however, ProFisheryObj_list should be used when StrategyObj is specified. The function requires ProFisheryObj to be entered as a list, allowing the user to modify vulnerability, retention, and discard scenarios during the projection phase across different areas. The wd argument is required and sets the working directory where the outputs of the projection will be saved. In this example, “Kole” is a subfolder of “data-test,” so all plots will be stored in “Kole.” The fileName argument specifies the output file name and can be set to the fileLabel defined above. This argument is always required. The doPlot argument is a logical value indicating whether to produce diagnostic plots upon completing simulations. The default is FALSE (no plots). The titleStrategy argument describes the title for the management strategy being evaluated and can be set to the projectionLabel. To explore all the arguments of this function, the user can use ?ProFisheryObj. Next, we present some of the plots produced by runProjection(). Figure 4.1: Spawning biomass by area- Higher_option1 Figure 4.2: Spawning biomass by area- Higher_option2 Figure 4.3: Spawning biomass by area- Higher_option3 Figure 4.4: Catch biomass by area- Higher_option1 Figure 4.5: Catch biomass by area- Higher_option2 Figure 4.6: Catch biomass by area- Higher_option3 4.5 Customized Management Procedures (MPs) Coming soon… 4.5.1 MP 1 add text 4.5.2 MP 2 add text "],["management-strategy-evalution-mse.html", "5 Management strategy evalution (MSE)", " 5 Management strategy evalution (MSE) Coming soon….. "],["exploring-results.html", "6 Exploring results", " 6 Exploring results Coming soon… "],["references.html", "References", " References Beverton, R. J. H., and S. J. Holt. 1957. On the Dynamics of Exploited Fish Populations. London: Her Majesty’s Stationery Office. Hordyk, Adrian R., Kotaro Ono, Jeremy D. Prince, and Carl J. Walters. 2016. “A Simple Length-Structured Model Based on Life History Ratios and Incorporating Size-Dependent Selectivity: Application to Spawning Potential Ratios for Data-Poor Stocks.” Canadian Journal of Fisheries and Aquatic Sciences 73 (12): 1787–99. https://doi.org/10.1139/cjfas-2015-0422. Pine III, William E, Carl J Walters, Edward V Camp, Rachel Bouchillon, Robert Ahrens, Leslie Sturmer, and Mark E Berrigan. 2015. “The Curious Case of Eastern Oyster Crassostrea Virginica Stock Status in Apalachicola Bay, Florida.” Ecology and Society 20 (3). Punt, André E., Doug S. Butterworth, Carryn L. de Moor, José A. A. De Oliveira, and Malcolm Haddon. 2016. “Management Strategy Evaluation: Best Practices.” Fish and Fisheries 17 (2): 303–34. https://doi.org/10.1111/faf.12104. Quinn, Terrance J, and Richard B Deriso. 1999. Quantitative Fish Dynamics. oxford university Press. R Core Team. 2022. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Walters, Carl J, and Steven JD Martell. 2004. Fisheries Ecology and Management. Princeton University Press. "]]
