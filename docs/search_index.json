[["index.html", "FishSimGTG: Population dynamics simulation 1 What is FishSimGTG? 1.1 Installation and required packages", " FishSimGTG: Population dynamics simulation Nature Analytics Version 1.0.7 2025-07-11 1 What is FishSimGTG? FishSimGTG is an R package that conducts numerical modeling of fish populations, including management strategy evaluation (MSE) and is an age-structured model that represents multiple concurrent cohorts using the growth-type-group methodology (Walters and Martell 2004). This framework is typically used to quantify trade-offs among competing management strategies or management options in terms of expected achievement of fishery management objectives. These trade-offs emerge from modeling results that are obtained from analysis methods like management strategy evaluation (MSE) or population dynamics projection. Calculation of trade-offs can play a meaningful role in supporting the development fishery management plans and fishery rule making. Simulations are implemented in the R statistical computing environment (R Core Team 2022). This framework is not a ‘black box’ software, and thus, it is intended to be customized to address specific questions related to fishery management. 1.1 Installation and required packages FishSimGTG is coded in R (R Core Team 2022) and requires some basic packages that can be installed as follows: Install R: Go to the CRAN website. Download and install the appropriate version of R for your operating system (Windows, macOS, or Linux). Install RStudio: Go to the RStudio website. Download and install RStudio Desktop (free version). Installing Required Packages: The user can install the necessary packages to run the simulation and visualize the outputs by using the following R commands: install.packages(&quot;devtools&quot;) library(devtools) devtools::install_github(&quot;natureanalytics-ca/fishSimGTG&quot;) devtools::install_github(&quot;natureanalytics-ca/fishSimTools&quot;) The devtools package is necessary because it allows us to install these core packages directly from GitHub, ensuring we have the latest versions and updates. Load the Required Packages: library(fishSimGTG) library(fishSimTools) The core packages required to run the simulation are fishSimGTG and fishSimTools. ## How to use FishSimGTG? The FishSimGTG package can be used to construct an operating model (OM) that simulates population and fishery dynamics, including data collection and the application of user-customized management procedures. The OM consists of several S4-type objects, such as the LifeHistory object, Fishery object, and TimeArea object, etc. These objects store parameters and information in slots, which users can access using the @ symbol. This user guide provides a full description of the S4 object components and instructions on how to populate each object to create the OM. References R Core Team. 2022. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Walters, Carl J, and Steven JD Martell. 2004. Fisheries Ecology and Management. Princeton University Press. "],["om.html", "2 Technical description 2.1 Population dynamics 2.2 Life history 2.3 Fishery dynamics 2.4 Observation and monitoring 2.5 Growth-type group", " 2 Technical description     This section describes the base configuration of the population dynamics equations used in the simulation framework. Please be aware that this configuration can be tailored to specific applications. An operating model is a mathematical representation of the biology of a fish stock, the fishery that operates on the fish stock, and ways in which the data is collected. The operating model should also include a sub-model that reflects how the management regulations are implemented and are adhered to in practice (Punt et al. 2016). 2.1 Population dynamics     The operating model (OM) describes the age-structured population dynamics of a fish population or stock. Population dynamics are specified for a single sex, with dynamics operating on an annual time step, and allowing for migration (of all age classes) between multiple areas. Abundance at age, \\(a\\), at the start of year \\(t\\), and in area \\(i\\), \\(N_{a,t,i}\\) is given by: \\[ N_{0,t,i} = \\rho_i R_t, \\tag{eq. 1} \\label{eq:first} \\] And, \\[ N_{a+1,t+1,i} = S_{a,t,i} \\left(N_{a,t,i}\\theta_{i \\rightarrow i}+\\sum_{j \\neq i} N_{a,t,j}\\theta_{j \\rightarrow i}\\right). \\tag{eq. 2} \\label{eq:second} \\] Equation \\(\\ref{eq:first}\\) is the fraction, \\(\\rho_i\\), of total age-0 recruits, \\(R_t\\), at the start of the year that are added to area \\(i\\). In equation \\(\\ref{eq:second}\\), the term in parenthesis describes the fraction of abundance-at-age that does not emigrate from area \\(i\\), \\(\\theta_{i \\rightarrow i}\\), plus the summation of abundance-at-age arriving from all other areas, \\(j\\), \\(\\theta_{a,j \\rightarrow i}\\). In this form, Equation \\(\\ref{eq:second}\\) specifies migration to occur at the beginning of the year, followed by survival, \\(S_{a,t,i}\\), from age \\(a\\) to age \\(a+1\\).     The multi-area model is implemented in matrix form, analogous to a Leslie matrix, as described by Quinn and Deriso (1999). For brevity, the matrix form is summarized using a two-area example, reflecting the description provided by Quinn and Deriso (1999), but note that the operating model is generalized as a multi-area model. To account for migration between two areas, \\(i\\) and \\(j\\), abundance-at-age in the matrix form is: \\[ \\mathbf{N}_{t+1} = \\mathbf{P}\\mathbf{N}_t, \\tag{eq. 3} \\label{eq:third} \\] where \\(\\mathbf{N}_t\\) for ages 0 to maximum age, \\(A\\), is written: \\[ \\mathbf{N}_t = \\begin{pmatrix} \\mathbf{N}_{t,i} \\\\ \\mathbf{N}_{t,j} \\end{pmatrix} = \\begin{pmatrix} N_{1,t,i} \\\\ \\vdots \\\\ N_{A,t,i} \\\\ N_{1,t,j} \\\\ \\vdots \\\\ N_{A,t,j} \\end{pmatrix}. \\tag{eq. 4} \\label{eq:fourth} \\] The projection matrix \\(\\mathbf{P}\\) is \\[ \\mathbf{P} = \\begin{pmatrix} P_{i,j} &amp; P_{i,j} \\\\ P_{i,j} &amp; P_{i,j} \\end{pmatrix}, \\tag{eq. 5} \\label{eq:fifth} \\] where each element, \\(P_{i,j}\\), is a matrix that accounts for movement and survival. The matrices, \\(P_{i,j}\\), are populated as: \\[ P_{i,i} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ S_{1,t,i}\\theta_{1,i\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_{2,t,i}\\theta_{2,i\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\ddots &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; S_{A-1,t,i}\\theta_{A-1,i\\rightarrow i} &amp; S_{A,t,i}\\theta_{A,i\\rightarrow i} \\end{pmatrix}, \\tag{eq. 6} \\label{eq:sixth} \\] And, \\[ P_{i,j} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ S_{1,t,i}\\theta_{1,j\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_{2,t,i}\\theta_{2,j\\rightarrow i} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\ddots &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; S_{A-1,t,i}\\theta_{A-1,j\\rightarrow i} &amp; S_{A,t,i}\\theta_{A,j\\rightarrow i} \\end{pmatrix}. \\tag{eq. 7} \\label{eq:seventh} \\] The operating model specifies a plus group in position (\\(A,A\\)).     Total annual recruitment is calculated according to the Beverton and Holt (1957) stock-recruitment function, which is parameterized using steepness \\((h)\\): \\[ R_t = \\left(\\frac{0.8R_0hB_t}{0.2B_0\\left(1-h\\right) + \\left(h-0.2\\right)B_t}\\right) \\exp{\\left(d_t - \\frac{{\\sigma_R}^2}{2}\\right)}, \\tag{eq. 8} \\label{eq:eighth} \\] where \\(B_0\\) is unfished reproductive output, \\(R_0\\) is unfished recruitment, and \\(d\\) is the annual recruitment deviation, where \\(\\sigma_R\\) is recruitment variability. Annual reproductive output, \\(B_t\\), is aggregate output (e.g., spawning biomass) for all areas combined, excluding any reproductive contribution of age-0 recruits created at the beginning of the year. Calculated total recruits are distributed to each area in proportion to the area-specific fraction, \\(\\rho_i\\), with \\(\\sum\\rho_i=1\\). An overall log-scale recruitment deviation signal (e.g., a surrogate for an environmental condition affecting recruitment success) is generated from a normal distribution with mean zero and standard deviation, \\(\\sigma_R\\), (e.g., \\(\\sigma_R\\) = 0.6). Inter-annual autocorrelation in recruitment can be specified, producing 1-year lagged correlation in log-scale recruitment deviations. 2.2 Life history     Length is calculated at the start of the year according to the von Bertalanffy growth curve, where \\(L_\\infty\\) is asymptotic length, \\(K\\) is the growth rate, and parameter \\(t_0\\): \\[ L_a = L_\\infty \\left(1- \\exp{\\left(-K\\left(a - t_0\\right)\\right)}\\right). \\tag{eq. 9} \\label{eq:nineth} \\] Weight-at-age, \\(W_a\\), with parameters \\(a\\) and \\(b\\) is specified as an exponential function: \\[ W_a=\\alpha L_a^\\beta. \\tag{eq. 10} \\label{eq:tenth} \\] Maturation follows a logistic function with parameters \\(L50\\) and \\(L95\\), reflecting the lengths at which 50% and 95% of the population are mature, respectively. Optionally, species can be specified as protogynous hermaphroditic species, with proportion of male in the population following an increasing logistic function with parameters \\(H50\\) and \\(H95\\), reflecting the lengths at which 50% and 95% of the population are male, respectively. For gonochoristic species, a 50:50 sex ratio is assumed at all lengths or ages. Total reproductive output, \\(B_t\\), is a summation of mature biomass across age classes and areas: \\[ B_t=\\sum_{i}\\sum_{a}{N_{a,t,i}W_a\\mathit{mat}_a{propFemale}_a}, \\tag{eq. 11} \\label{eq:eleventh} \\] Where \\(propFemale\\) is proportion of the population female at age, with a value of 0.5 for all ages for gonochoristic species and values of 1-\\(propMale_a\\) when sexual transition from female to male is specified.     Both natural mortality and maximum age can be specified. When maximum age, \\(A\\), is specified, this quantity is used in constructing abundance matrices. Maximum must be equal to or greater than 2, as this modeling framework is not well suiting to species with very fast life histories. When maximum age is not specified, the age to which 1% the population survives in an unfished system is used to calculate maximum age, using the formula: \\[ A=\\ ceiling\\left(-\\frac{\\log{\\left(0.01\\right)}}{M}\\right) \\tag{eq. 12} \\label{eq:twelftth} \\] Uncertainty in life history can be accounted for by specifying parameter ranges, rather than point estimates for most life history parameters. Each iteration will produce a unique set of life history parameters based on independent draws from uniform distributions that correspond to the specified minimum and maximum for each parameter. 2.3 Fishery dynamics     Survival (\\(S\\)) consists of natural mortality (\\(M\\) year\\(^{-1}\\), fishing mortality (\\(F\\) year\\(^{-1}\\)): \\[ S_{a,t,i}=exp{\\left(-M-{\\mathit{Removal}}_aF_{t,i}\\right)}, \\tag{eq. 13} \\label{eq:thirteenth} \\] where \\(Removal\\) is a component of fishery selectivity and is covered in a subsequent section. Landings in numbers (\\(C^{N}\\) is: \\[ C_{a,t,i}^N=\\frac{{\\mathit{Keep}}_aF_{t,i}}{\\left(M_s+{\\mathit{Removal}}_aF_{t,i}\\right)}\\left(1-S_{a,t,i}\\right)N_{a,t,i}, \\tag{eq. 14} \\label{eq:fourteenth} \\] and \\(keep\\) is a component of fishery selectivity. Landings in weight (\\(C^B\\)) is: \\[ C_{a,t,i}^B=C_{a,t,i}^NW_a \\tag{eq. 15} \\label{eq:fifteenth} \\] Fishery selectivity is defined as follows. Vulnerability to the fishing gear includes several options. Retention, \\(Ret\\), can be specified as ‘full’, resulting in full retention across all vulnerable size classes, ‘logistic’ or ‘slot limit’. Additionally, the maximum level of retention (e.g., a quantity between 0 and 1) can be specified for any of the above stated retention types. Finally, a discard mortality proportion, \\(D\\), (e.g. quantity between 0 and 1) can be specified to affect the fate of discards. These inputs are used in calculating the following components of fishery selectivity. Note: vulnerability and retention are specified as functions of length. These components of fishery selectivity are converted to age using corresponding length-at-age. \\(Keep\\) - the resulting probability of being landed \\[ Keep_a=Vul_aRet_a \\tag{eq. 16} \\label{eq:sixteenth} \\] \\(Dead\\,discards\\) - deaths resulting from vulnerable abundance that is not retained \\[ Dead\\,discards_a=Vul_a(1-Ret_a)D \\tag{eq. 17} \\label{eq:seventeenth} \\] \\(Total\\,removals\\) – probability of removal from the population via landing or discard \\[ Removal_a=Vul_a(Ret_a+(1-Ret_a)D) \\tag{eq. 18} \\label{eq:eighteenth} \\] Uncertainty in vulnerability and retention can be accounted for by specifying parameter ranges, rather than point estimates. Each iteration will produce a unique selectivity and/or retention characteristics based on independent draws from uniform distributions that correspond to the specified minimum and maximum for each parameter. 2.4 Observation and monitoring     Depending on the specific application of the model, an observation model may be required. This requirement is driven by whether a harvest control rule is used in decision-making. That is, whether some form of data collection will inform year-to-year adjustments in a total allowable catch or total fishery effort. If so, then simulation of the data observation processes (including imperfect observation) is required. Observation models tend to be tailored to the type of data collection program that is in place. This component should be developed as needed for each unique application. 2.5 Growth-type group To account for individual variation in growth trajectories, the population is divided into growth-type groups (GTGs) or cohorts Hordyk et al. (2016). GTGs describe the variation in growth of a fish population through the creation of \\(G\\) groups and with dimensions indexed \\(g=1,2…G\\). Each group differs in terms of its \\(L_\\infty\\). Given a mean value, \\(\\bar{L}_\\infty\\) and a standard deviation (calculated as a coefficient of variation, \\(CV_L\\) times \\(\\bar{L}_\\infty\\)), the range of \\(L_\\infty\\) ± two standard deviations is divided into \\(G\\) equal increments. A default value of \\(CV_L\\) = 0.1 and \\(G\\) = 13 groups, results in \\(g\\) = 7 representing \\(\\bar{L}_\\infty\\). Cohort size assigned to each group is determined by distributing a fraction of annual recruits in each group, \\(p\\), where \\(\\sum{p}=1\\). Vector \\(p\\) is determined as proportional to the \\(G\\) increments in \\(L_\\infty\\) along the probability density function of a normal distribution with mean \\(\\bar{L}_\\infty\\) and variance \\(\\left(CV_L{\\bar{L}}_\\infty\\right)^2\\). Functionality is also included such that if \\(G\\) = 1, the model collapses to a simpler age-based model. References Beverton, R. J. H., and S. J. Holt. 1957. On the Dynamics of Exploited Fish Populations. London: Her Majesty’s Stationery Office. Hordyk, Adrian R., Kotaro Ono, Jeremy D. Prince, and Carl J. Walters. 2016. “A Simple Length-Structured Model Based on Life History Ratios and Incorporating Size-Dependent Selectivity: Application to Spawning Potential Ratios for Data-Poor Stocks.” Canadian Journal of Fisheries and Aquatic Sciences 73 (12): 1787–99. https://doi.org/10.1139/cjfas-2015-0422. Punt, André E., Doug S. Butterworth, Carryn L. de Moor, José A. A. De Oliveira, and Malcolm Haddon. 2016. “Management Strategy Evaluation: Best Practices.” Fish and Fisheries 17 (2): 303–34. https://doi.org/10.1111/faf.12104. Quinn, Terrance J, and Richard B Deriso. 1999. Quantitative Fish Dynamics. oxford university Press. "],["om-pop.html", "3 Operating Model (OM) 3.1 Time area object 3.2 Life history object 3.3 Historical fishery object 3.4 Stochastic object 3.5 Initial conditions 3.6 Historical dynamics", " 3 Operating Model (OM) The OM is comprised of three required objects in S4 format: Life history object (LifeHistoryObj) Historical fishery object (HistFisheryObj) Time-area object (TimeAreaObj) Optional: Stochastic object (StochasticObj) Each of these S4 objects contains a specific number of slots, which can be accessed using the slotNames() function. These slots are populated within R. The simplest way to start building the OM is to create a new object using the R function new() and populate it with the required input information and parameters. The first step, before populating the slots of each object, is to create a new object using the new() function. 3.1 Time area object The TimeAreaObj object holds temporal and spatial elements of the operating model, including descriptions of time steps, growth-type groups (GTGs), and spatial area parameters. The FishSimGTG package allows the user to model migration between multiple areas. To create a new object of class TimeArea, use the new() function as follows: TimeAreaObj&lt;-new(&quot;TimeArea&quot;) To populate the slots of the TimeAreaObj object, the user should start by defining a meaningful title (title). Similar to the other S4 objects, the slot names of the TimeAreaObj can be viewed using the slotNames() function, and the user can access the help file using the ? symbol. slotNames(TimeAreaObj) ## [1] &quot;title&quot; &quot;gtg&quot; &quot;areas&quot; &quot;recArea&quot; ## [5] &quot;move&quot; &quot;iterations&quot; &quot;historicalYears&quot; &quot;historicalBio&quot; ## [9] &quot;historicalBioType&quot; &quot;historicalEffort&quot; #getting help ?`TimeArea-class` TimeAreaObj@title = &quot;Test&quot; TimeAreaObj@gtg = 13 TimeAreaObj@areas = 2 TimeAreaObj@recArea = c(0.99, 0.01) TimeAreaObj@iterations = 100 TimeAreaObj@historicalYears = 10 TimeAreaObj@historicalBio = 0.5 TimeAreaObj@historicalBioType = &quot;relB&quot; TimeAreaObj@move = matrix(c(1,0, 0,1), nrow=2, ncol=2, byrow=FALSE) TimeAreaObj@historicalEffort = matrix(1:1, nrow = 10, ncol = 2, byrow = FALSE) The FishSimGTG package allows for accounting for individual variation in growth trajectories by dividing the population into growth-type groups (GTGs), so each age class is divided into a collection of smaller cohorts or GTGs. The gtg slot in TimeAreaObj represents the number of growth-type groups, with a default value of 13. areas represents the number of areas in the model, and it must be greater than 1, even when a single-area model is desired. recArea is a vector of length areas. Each element of the vector represents the fraction of recruitment to each area, with the values summing to 1. In this example, 0.99 of the recruitment is assigned to area 1, and 0.01 to area 2, implying that the model is treated similarly to a single-area model. iterations is the number of iterations to run (i.e., the number of simulations). historicalYears are the number of years to simulate historical dynamics. historicalBio is a value grater than 0 and less than 1. The model assumes the population does not start in unfished conditions. historicalBioTypeis a string, that represents the type of historical biomass state. The options are: “relB” (relative spawning biomass) or “SPR” (Spawning Potential Ratio). move is a matrix of migration rates of dimensions areas x areas. historicalEffort is a matrix of nrows = historicalYears and ncols = areas that contains value multipiers of initial equilibrium fishing mortality. In its current form, FishSimGTG is specified such that fishing mortality rate is proportional to fishing effort. Thus, where historical patterns of fishing effort are available, these can be re-scaled as multipliers of the initial equilibrium fishing mortality. 3.2 Life history object The LifeHistoryObj is an S4 object of the class LifeHistory that holds the description of a life history. To create a new object of class LifeHistory, use the new() function, as follows: LifeHistoryObj &lt;- new(&quot;LifeHistory&quot;) The user can see the elements or slots of the LifeHistoryObject using the slotNames() function. slotNames(LifeHistoryObj) ## [1] &quot;title&quot; &quot;speciesName&quot; &quot;shortDescription&quot; &quot;L_type&quot; ## [5] &quot;L_units&quot; &quot;Walpha_units&quot; &quot;Linf&quot; &quot;K&quot; ## [9] &quot;t0&quot; &quot;L50&quot; &quot;L95delta&quot; &quot;M&quot; ## [13] &quot;MK&quot; &quot;LW_A&quot; &quot;LW_B&quot; &quot;Tmax&quot; ## [17] &quot;Steep&quot; &quot;R0&quot; &quot;recSD&quot; &quot;recRho&quot; ## [21] &quot;isHermaph&quot; &quot;H50&quot; &quot;H95delta&quot; The user can access the help file for classes by using ? symbol ?`LifeHistory-class` In the help file, the user will find a description of the LifeHistoryObject and the elements or slots it contains. To populate the rest of the slots of the LifeHistoryObject, the user should start by defining a useful title (title), followed by the scientific name of the species (speciesName). If desired, the user can add a short description (shortDescription) of the object. LifeHistoryObj@title&lt;-&quot;Kole&quot; LifeHistoryObj@speciesName&lt;-&quot;Ctenochaetus strigosus&quot; LifeHistoryObj@shortDescription&lt;-&quot;stock name/location&quot; Then, the user can proceed to populate the rest of the slots as follows: LifeHistoryObj@Linf&lt;-17.7 LifeHistoryObj@K&lt;-0.423 LifeHistoryObj@t0&lt;- -0.51 LifeHistoryObj@L50&lt;-8.4 LifeHistoryObj@L95delta&lt;-1.26 LifeHistoryObj@M&lt;-0.08 LifeHistoryObj@L_type&lt;-&quot;FL&quot; LifeHistoryObj@L_units&lt;-&quot;cm&quot; LifeHistoryObj@LW_A&lt;-0.046 LifeHistoryObj@LW_B&lt;-2.85 LifeHistoryObj@Steep&lt;-0.54 LifeHistoryObj@recSD&lt;-0 LifeHistoryObj@recRho&lt;-0 LifeHistoryObj@isHermaph&lt;-FALSE LifeHistoryObj@R0&lt;-10000 Growth is modeled in the FishSimGTG package using a von Bertalanffy growth curve, where Linf represents the asymptotic length, K the Brody growth rate coefficient (with units in yr\\(^{-1}\\)), and t0 represents the time or age when the average length was zero. Maturity parameters are represented by the L50 and L95delta parameters, assuming that maturity is size-dependent and follows a logistic model. The L50 is the length at 50% maturity, and the L95delta is the length increment between L50 and the length at 95% maturity. L95delta must be a value larger than 0. M, represent the natural mortality rate per year. L_type represents the method of measuring length. e.g. \"TL\" for total length or \"FL\" for fork length. Must be consistent for all length parameters (e.g., Linf, L50, L95delta). L_units, are the units of measure (\"cm\" is expected). L_units must be consistent for all length parameters (e.g., Linf, L50, L95delta). LW_A and LW_B are the parameters of the allometric length-weight relationship. Walpha_units (help file-W_units)represents the measurement units of weight and must be consistent with the LW_A and LW_B parameters. Recruitment is modeled using a Beverton-Holt stock-recruitment relationship, parameterized in terms of steepness (Steep). Values for Steep range between &gt;0.2 to 1. R0 represents the initial number of unfished recruits (positive number). Recruitment process error is generated from a normal distribution with mean zero and standard deviation represented by recSD. Autocorrelation in recruitment deviations in log space are defined by recRho, producing 1-year lagged correlation. recSD and recRho, are non-negative real numbers. The FishSimGTG package allows for modeling the population dynamics of gonochoristic and protogynous hermaphroditic species. The user will set isHermaph to TRUE when the species is a protogynous hermaphrodite and to FALSE when it is a gonochoristic species. If the species is a protogynous hermaphrodite, the user will need to define two additional parameters: H50 and H95delta. H50 represents the length at which 50% of the population are male, and H95delta represents the length increment between H50 and length at which 95% of the population are male. H95delta must be a value larger than 0. MK and Tmax are optional parameters. MK represents the M/K ratio (natural mortality divided by von Bertalanffy K coefficient) and is not utilized by FishSimGTG; however, sister R packages such as fishLengthAssess can utilize this parameter as part of length-based stock assessment. To utilize functionality within FishSimGTG, M and K should be specified in separate slots. Tmax is the maximum observed age that defines the plus-group in modeling population dynamics. When Tmax is not specified (the default), the age to which 1% the population survives in an unfished system is used to calculate Tmax. When Tmax is specified, it must take on a quantity equal to or greater than 2. The FishSimGTG package includes several plotting functions that allow users to explore the simulated life history before proceeding to analysis. The life history schedules can be plotted using the LHwrapper() function. This function displays the plot in the console and also returns all the details of the life history. The user can access the help file for the LHwrapper() function by using the ? symbol (?LHwrapper). #To simply display to the console lhOut&lt;-LHwrapper(LifeHistoryObj, TimeAreaObj, doPlot = TRUE) Figure 3.1: Life history schedules. The upper panels represent the von Bertalanffy growth curve (left) and the maturity ogive (right). The bottom panels represent the weight-at-age relationship and the allometric length-weight relationship. lhOut returns all the details of the life history. #To return life history details lhOut 3.3 Historical fishery object The HistFisheryObj is an S4 object of the class Fishery that holds fishery characteristics, including vulnerability, retention, and discard information. In its current configuration, the characteristics defined in the HistFisheryObj apply to all areas. Doing so enables rapid calculation of initial stable age distribution within each area. This structure should be interpreted as the state of the resource prior to any spatial management, or alternatively, as homogeneous fishery characteristics across all areas. To create a new object of class Fishery, use the new() function, as follows: HistFisheryObj&lt;-new(&quot;Fishery&quot;) The slot names of the HistFisheryObj can be seen using the slotNames() function. slotNames(HistFisheryObj) ## [1] &quot;title&quot; &quot;vulType&quot; &quot;vulParams&quot; &quot;retType&quot; &quot;retParams&quot; &quot;retMax&quot; &quot;Dmort&quot; The user can access the help file using ? symbol ?`Fishery-class` In the help file, the user will find a description of the HistFisheryObj and the elements or slots it contains. To populate the slots, the user should start by defining a meaningful title (title), followed by specifying the selectivity/vulnerability, retention, and discard information. HistFisheryObj@title&lt;-&quot;Test&quot; HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(10.2,0.1) #Approx. knife edge HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 3.3.1 Selectivity Selectivity or vulnerability is the probability of being selected or becoming vulnerable to the fishing gear. In the FishSimGTG package, selectivity is defined with respect to length, with a maximum value of 1 enforced. vulType describes the type of selectivity/vulnerability function for the historical time period. The user can see a detailed description of the different selectivity functions by exploring the ?selWrapper function. Common vulnerability types: “logistic” selectivity with two parameters (vulParams) represented by the length at 50% of selectivity and the length increment between the length at 50% of selectivity and the length at 95% selectivity. “explog” is an exponential logistic selectivity (dome-shaped) function, defined by three parameters (vulParams), represented as c(p1, peak, and p3). To use the “explog” function, the user must first provide the ascending rate (p1), which should be within the range of 0.02 to 1. Next, the user needs to define the peak of the vulnerability function, which corresponds to the location of the peak of the dome-shaped selectivity curve or the length at which selectivity is highest. As an aside, this peak is used to calculate p2, which determines the position of the peak relative to the range of lengths. For example, if the length range is between 1 and 20 cm, and p2 is set to 0.5, the peak will be at 10 cm. Given p2, the peak can be calculated using the following equation: \\[ \\text{peak} = \\text{min}(\\text{Length}) + p_2 \\times (\\text{max}(\\text{Length}) - \\text{min}(\\text{Length})) \\] p2 must be within the range of 0.01 to 0.9, with a reasonable starting value of 0.5. By adjusting p2, the user can shift the peak along the length range, from the minimum length to the maximum length. Finally, the user must provide p3, which is the descending rate, and which must be within the range of 0.001 to 0.5. A value of 0.001 provides a nearly asymptotic curve, while values above 0.2 produce a strongly dome-shaped function, where the p3 and p1 parameters interact strongly. 3.3.2 Retention Retention is the probability of being retained (kept by the fleet) and not discarded. It describes both the shape with respect to length and the maximum value, which can be less than 1. Fish that are selected by the fishing gear but not retained are discarded (discard mortality rate). The probability of being landed (keep), is calculated as Vulnerability × Retention. The user can see a detailed description of the different retention types by exploring the ?selWrapper function. There are three retention types (retType): “full” retention assumes that keep is equal to retention. There are no parameters (retParams) for “full” retention. “logistic” retention has two parameters (retParams): the length at 50% retention and the length increment to 95% retention. “slotLimit” retention includes two parameters (retParams): minimum length and maximum length, where catches occur between the minimum and maximum values. retMax is a numeric value between 0 and 1 that defines the peak of the retention curve. 3.3.3 Discard mortality rate Discard mortality rate represents the fish that are selected but not retained, and are therefore subject to the discard mortality rate (Dmort). Dmort is the fraction of discards that are killed (e.g., 0.25 means 25% are killed). This value must be between 0 and 1. 3.3.4 Fishery plots The FishSimGTG package includes several plotting functions that allow users to explore the simulated Vulnerability, retention, keep, dead discards, and removals at length. Fishery characteristics can be plotted using the selWrapper() function. This function displays the plot in the console. The user can access the help file for the selWrapper() function by using the ? symbol (?selWrapper). selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.2: Logistic selectivity function. selOut returns all the details of the fishery selectivity. #To return sel details selOut If the user modifies the vulnerability, retention, and discard parameters in the HistFisheryObj, other selectivity/vulnerability and retention shapes can be explored. For example: – Assuming a vulnerability type vulType of “explog”, with parameters p1, peak, and p3. HistFisheryObj@vulType&lt;-&quot;explog&quot; HistFisheryObj@vulParams&lt;-c(0.9,10,0.15) #dome-shaped HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.3: Exponential logistic selectivity (dome-shaped). – Assuming a vulnerability type vulType of “logistic”, with changes in the retention type (retType) and retention parameters (retParams). HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(10.2,0.1) #Approx. knife edge HistFisheryObj@retType&lt;-&quot;logistic&quot; HistFisheryObj@retParams&lt;-c(11,0.8) HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.4: Logistic selectivity function with different retention parameters. 3.4 Stochastic object The StochasticObj is used as a catch-all object for specifying magnitude of variation in input parameters, in two ways. Its first usage, and technically poor use of the term ‘stochastic’, is to represent a modeling approach that accounts for uncertainty in various input parameters (e.g., initial depletion, life history, selectivity, and annual recruitment deviations). Its second usage is to represent inter-annual variation (not yet implemented, except for recruitment deviations that are specified within a LifeHistoryObject). The StochasticObj holds the parameters for characterizing uncertainty about population and fishery dynamics. To create a new object of class Stochastic, use the new() function. StochasticObj&lt;-new(&quot;Stochastic&quot;) Similar to other S4 objects, the slot names of StochasticObj can be viewed using the slotNames() function, and the help file can be accessed using the ? symbol. slotNames(StochasticObj) ## [1] &quot;title&quot; &quot;historicalBio&quot; &quot;Linf&quot; ## [4] &quot;K&quot; &quot;L50&quot; &quot;L95delta&quot; ## [7] &quot;M&quot; &quot;Steep&quot; &quot;recSD&quot; ## [10] &quot;recRho&quot; &quot;H50&quot; &quot;H95delta&quot; ## [13] &quot;histFisheryVul&quot; &quot;proFisheryVul_list&quot; &quot;sameFisheryVul&quot; ## [16] &quot;histFisheryRet&quot; &quot;proFisheryRet_list&quot; &quot;sameFisheryRet&quot; ## [19] &quot;histFisheryDmort&quot; &quot;proFisheryDmort_list&quot; &quot;sameFisheryDmort&quot; #getting help ?`Stochastic-class` To populate the slots of StochasticObj, the user should begin by defining a meaningful title (title) and specifying the parameters in which they want to include variation. The slots defined in the StochasticObj object create additional inputs and override parameters specified elsewhere (e.g., LifeHistoryObj, HistFisheryObj, or TimeAreaObj), allowing the corresponding model components to become random processes. Values for these components are generated ahead of simulation and retained to ensure reproducibility of results. In the following example, we add uncertainty to historicalBio. As state of depletion can be uncertain, initial depletion can be implemented as a range of plausible values, producing slightly different values for each iteration. This is achieved by assigning a vector of length 2 that contains the lower and upper bounds of a uniform distribution to the slot StochasticObj@historicalBio. Doing so will override (replace) the quantity defined in the TimeAreaObj object (TimeArea@historicalBio). For each iteration, one value is drawn from a uniform distribution. Importantly, TimeArea@historicalBioType continues to determine the type of historical biomass state (e.g., ‘relB’ or ‘SPR’). StochasticObj@title&lt;-&quot;adding unceratinty&quot; StochasticObj@historicalBio = c(0.3, 0.6) 3.4.1 Uncertainty in life history All scalar parameters in the LifeHistoryObj object that hold a single value, such as Linf, K, L50, L95delta, M, Steep, recSD, recRho, H50, and H95delta, can be redefined in the StochasticObj object. When redefined, they are replaced by a vector of length 2 containing the minimum and maximum values. If provided, these values override those in the LifeHistoryObj, and a unique value for each iteration is generated by sampling from the uniform distribution. StochasticObj@Steep = c(0.5, 0.6) #e.g., adding stochasticity to Steepness 3.4.2 Uncertainty in the historical fishery A matrix with \\(n\\) columns and 2 rows is used to define the range of uncertainty for the vulnerability (vulParams) and retention (retParams) parameters from the HistFisheryObj in the StochasticObj object. Row 1 contains the minimum values, and row 2 contains the maximum values for each parameter, corresponding to the respective column \\(n\\). When this matrix is provided in the StochasticObj object, it replaces the vulParams and retParams slots previously defined in the HistFisheryObj. This ensures that the columns of the matrix align with the required inputs for vulType and retType in the HistFisheryObj object. The same logic applies to redefining the Dmort parameter, but in this case, the matrix contains only 1 column and 2 rows (min and max), as the Dmort parameter is a scalar. When this matrix is provided, it replaces the Dmort slot in the HistFisheryObj. #just to continue with the original configuration of sel and retention HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(10.2,0.1) #Approx. knife edge HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 StochasticObj@histFisheryVul=matrix(c(9,11,0.07,0.13), nrow=2, ncol=2,byrow=FALSE) #e.g., adding stochasticity to histFisheryVul There are additional slots in the StochasticObj object that modify fishery projections (ProFisheryObj), which will be described in detail in a separate section. 3.5 Initial conditions     This modeling framework was developed to create historical dynamics of fish stocks that begin (i.e., year 0) in a fished state, meaning that fishing mortality (and consequently fishing effort) are greater than zero in the initial equilibrium year (year 0). Thus, the modeling framework is not suitable for circumstances for initializing the model in an unfished or pre-fishing state. Accordingly, initial depletion (spawning biomass relative to unfished spawning biomass) should always be less than 1.0. An alternative formulation is available where initial ‘depletion’ can instead be specified as initial Spawning Potential Ratio (SPR). SPR is spawning biomass per recruit relative to unfished spawning biomass per recruit). Subsequently, the population is initialized as follows. First, equilibrium age-structure is determined for the given depletion or SPR level assuming area-specific recruitment fractions, \\(\\rho_i\\), but no movement, resulting in an equilibrium fishing mortality rate and equilibrium abundance scaled relative to the specified \\(R_0\\). Second, a burn-in period is used to project the population forward for \\(A\\)x4 years at the estimated equilibrium fishing mortality rate, allowing a stable age distribution between areas to be obtained through migration. 3.6 Historical dynamics This example illustrates specification of an operating model (OM) and simulation of historical dynamics. # Load necessary package library(fishSimGTG) library(fishSimTools) library(here) 3.6.1 Populate the life history object LifeHistoryObj &lt;- new(&quot;LifeHistory&quot;) LifeHistoryObj@title&lt;-&quot;Hawaiian Uhu - Parrotfish&quot; LifeHistoryObj@speciesName&lt;-&quot;Chlorurus perspicillatus&quot; LifeHistoryObj@Linf&lt;-53.2 LifeHistoryObj@K&lt;-0.225 LifeHistoryObj@t0&lt;- -1.48 LifeHistoryObj@L50&lt;-35 LifeHistoryObj@L95delta&lt;-5 LifeHistoryObj@M&lt;-0.16 LifeHistoryObj@L_type&lt;-&quot;FL&quot; LifeHistoryObj@L_units&lt;-&quot;cm&quot; LifeHistoryObj@LW_A&lt;-0.0136 LifeHistoryObj@LW_B&lt;-3.109 LifeHistoryObj@Steep&lt;-0.6 LifeHistoryObj@isHermaph&lt;-TRUE LifeHistoryObj@H50&lt;-46.2 LifeHistoryObj@H95delta&lt;-11.8 LifeHistoryObj@recSD&lt;-0.6 LifeHistoryObj@recRho&lt;-0 LifeHistoryObj@R0&lt;-10000 3.6.2 Populate the historical fishery object HistFisheryObj&lt;-new(&quot;Fishery&quot;) HistFisheryObj@title&lt;-&quot;Test&quot; HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(40, 1) HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 3.6.3 Populate the time-area object #This setup will be used to produce a single-stock with no movement. #fishSimGTG requires specifying a minimum of two areas. #However, we will treat those areas as a homogeneous fish stock by applying the same F to each area (see TimeAreaObj@historicalEffort) TimeAreaObj&lt;-new(&quot;TimeArea&quot;) TimeAreaObj@title = &quot;Example&quot; TimeAreaObj@gtg = 13 TimeAreaObj@areas = 2 TimeAreaObj@recArea = c(0.99, 0.01) TimeAreaObj@iterations = 3 TimeAreaObj@historicalYears = 50 TimeAreaObj@historicalBio = 0.5 TimeAreaObj@historicalBioType = &quot;relB&quot; TimeAreaObj@move &lt;- matrix(c(1,0, 0,1), nrow=2, ncol=2, byrow=FALSE) TimeAreaObj@historicalEffort&lt;-matrix(1:1, nrow = 50, ncol = 2, byrow = FALSE) 3.6.4 Review life history characteristics The function LHwrapper can be used to verify the paramaterization of the LifeHistoryObj object. Set doPlot to TRUE to produce a plot of life history characteristics. #To simply display to the console lhOut&lt;-LHwrapper(LifeHistoryObj, TimeAreaObj, doPlot = TRUE) Figure 3.5: Life history summary. #To return life history details lhOut 3.6.5 Review fishery characteristics The function selWrapper can be used to verify the paramaterization of the FisheryObj object. Set doPlot to TRUE to produce a plot of fishery characteristics. selOut&lt;-selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 3.6: Fishery summary. #To return fishery details selOut 3.6.6 Populate optional key uncertainties #Populate the optional Stochastic object. #Here, initial biomass range is set. A value for each iteration is drawn from a uniform distribution StochasticObj&lt;-new(&quot;Stochastic&quot;) StochasticObj@historicalBio = c(0.3, 0.6) 3.6.7 Generate historical dynamics With the following objects specified, historical dynamics are simulated using the function runProjection (See Section 6). Life history object (LifeHistoryObj) Historical fishery object (HistFisheryObj) Time-area object (TimeAreaObj) (optional) Stochastic object (StochasticObj) Notice that only historical dynamics are simulated when MP objects StrategyObj and ProFisheryObj_list are omitted from runProjection. Below, the diagnostic plots produced by runProjection illustrate patterns in the historical dynamics. #To return life history details runProjection(LifeHistoryObj = LifeHistoryObj, TimeAreaObj = TimeAreaObj, HistFisheryObj = HistFisheryObj, StochasticObj = StochasticObj, wd = here(&#39;data-test&#39;, &#39;Historical&#39;), fileName = &quot;HistoricalDy&quot;, doPlot = TRUE, titleStrategy = &quot;HistoricalDy&quot; ) ## [1] &quot;\\n #---------------\\n #Initial checks\\n #---------------\\n &quot; ## [1] &quot;Uncertainty in initial biomass: 0.3 to 0.6 relB created.&quot; ## [1] &quot;Uncertainty in life history parameters: none&quot; ## [1] &quot;Uncertainty in historical fishery selectivity parameters: none&quot; ## [1] &quot;Area 1 uncertainty in projection fishery selectivity parameters: none&quot; ## [1] &quot;Area 2 uncertainty in projection fishery selectivity parameters: none&quot; ## [1] &quot;Simulation time in minutes: &quot; ## user system elapsed ## 0.020333333 0.001333333 0.023166667 Figure 3.7: Spawning biomass by area Figure 3.8: Catch biomass by area Figure 3.9: Fishing mortality by area- Higher_option2 Figure 3.10: Relative spawning stock biomass, in aggregate across areas "],["observation-sub-model.html", "4 Observation sub-model", " 4 Observation sub-model Coming soon….. "],["management-procedure-mp.html", "5 Management Procedure (MP) 5.1 Strategy object 5.2 Projection fishery object 5.3 MP Template 5.4 MP library", " 5 Management Procedure (MP) A Management Procedure (MP) is a pre-agreed process defining how a fishery will be managed, with the primary role being to take fishery information and return a management recommendation. FishSimGTG allows the user to create custom MPs and simulation-test their performance using management strategy evaluation (MSE). Evaluating an MP requires specifying the objects of the OM as well as two additional S4-type objects. As previously discussed, the OM is comprised of three required objects in S4 format: Life history object (LifeHistoryObj) Historical fishery object (HistFisheryObj) Time-area object (TimeAreaObj) With optional: Stochastic object (StochasticObj) And, producing forward-simulation (e.g., implementing an MP and evaluating its performance) requires two additional objects in S4 format: Management procedure or harvest strategy object (StrategyObj) Forward projection time period fishery object (ProFisheryObj) 5.1 Strategy object The StrategyObj holds a set of instructions about how the fishery will be managed. To create a new object of class StrategyObj, use the new() function. StrategyObj&lt;-new(&quot;Strategy&quot;) The user can see the elements or slots of the StrategyObj using the slotNames() function. slotNames(StrategyObj) ## [1] &quot;title&quot; &quot;projectionYears&quot; &quot;projectionName&quot; &quot;projectionParams&quot; To populate the StrategyObj, the user should start by specifying a title (title) and the number of forward projection years to simulate (projectionYears). The projectionName is a string that directs to a named function that contains an algorithm describing how the fishery will be managed. And, projectionParams is a list of input parameters that will be utilized by the projection function defined in projectionName. Developing the necessary code to create a custom StrategyObj can be very challenging. Before designing an MP, the user is advised to first explore Projection Modeling in section 8.1. Projection modeling differs from an MP in that projections consist of ‘static’ actions such as a size limit or constant fishing effort, whereas MPs are ‘dynamic’ responses to updated information (e.g., pre-agreed responses to observations of the fishery system), including, for example, annual adjustments to catch limits. MPs tend to be more complicated because they include a harvest control rule or decision-rule that is informed by updated information gathered from monitoring. While FishSimGTG requires custom coding to produce an MP, projection modeling can be carried out using built-in functions. 5.2 Projection fishery object The ProFisheryObj is an S4 object of the class Fishery that holds fishery characteristics, including vulnerability, retention, and discard information. Note that both the HistFisheryObj and ProFisheryObj utilize the same S4 object class. HistFisheryObj and ProFisheryObj are both Fishery objects. When no changes in the fishery characteristics are anticipated during forward projections, the slots of ProFisheryObj can be set to the same values as those in HistFisheryObj ProFisheryObj&lt;-HistFisheryObj Alternatively, the user has the option to modify the HistFisheryObj object when performing forward projections. These modifications are stored in a new ProFisheryObj. To create a new object of class Fishery, use the new() function, as follows: ProFisheryObj&lt;-new(&quot;Fishery&quot;) The slot names of the ProFisheryObj can be seen using the slotNames() function. slotNames(ProFisheryObj) ## [1] &quot;title&quot; &quot;vulType&quot; &quot;vulParams&quot; &quot;retType&quot; &quot;retParams&quot; &quot;retMax&quot; &quot;Dmort&quot; The user can access the help file using ? symbol ?`Fishery-class` ProFisheryObj can be populated as follows: ProFisheryObj@title&lt;-&quot;Test&quot; ProFisheryObj@vulType&lt;-&quot;logistic&quot; ProFisheryObj@vulParams&lt;-c(10.2,0.1) ProFisheryObj@retType&lt;-&quot;logistic&quot; ProFisheryObj@retParams &lt;- c(15, 0.1) ProFisheryObj@retMax &lt;- 1 ProFisheryObj@Dmort &lt;- 0 In this example, during the projections, we maintain the same vulnerability type and parameters as in the HistFisheryObj object but modify retention to follow a logistic function. 5.2.1 Fishery spatial considerations As noted, fishery characteristics can be modified between the historical and forward projection time periods. Additionally, fishery characteristics can vary between spatial areas during forward projection. The number of ProFisheryObj specified must be equal to the number of areas defined by TimeAreaObj@areas. ProFisheryObj must be contained in a list, with examples as follows: #Two-area OM, with no change in fishery characteristics between historical and forward projection time periods. ProFisheryObj&lt;-HistFisheryObj ProFisheryObj_list = list(ProFisheryObj, ProFisheryObj) #Two-area OM, with no spatial differences in fishery characteristics during forward projection. ProFisheryObj&lt;-new(&quot;Fishery&quot;) ProFisheryObj@title&lt;-&quot;Test&quot; ProFisheryObj@vulType&lt;-&quot;logistic&quot; ProFisheryObj@vulParams&lt;-c(10.2,0.1) ProFisheryObj@retType&lt;-&quot;logistic&quot; ProFisheryObj@retParams &lt;- c(15, 0.1) ProFisheryObj@retMax &lt;- 1 ProFisheryObj@Dmort &lt;- 0 ProFisheryObj_list = list(ProFisheryObj, ProFisheryObj) #Two-area OM, with spatial differences in fishery characteristics during forward projection. ProFisheryObj1&lt;-new(&quot;Fishery&quot;) ProFisheryObj1@title&lt;-&quot;FisheryArea1&quot; ProFisheryObj1@vulType&lt;-&quot;logistic&quot; ProFisheryObj1@vulParams&lt;-c(10.2,0.1) ProFisheryObj1@retType&lt;-&quot;logistic&quot; ProFisheryObj1@retParams &lt;- c(15, 0.1) ProFisheryObj1@retMax &lt;- 1 ProFisheryObj1@Dmort &lt;- 0 ProFisheryObj2&lt;-new(&quot;Fishery&quot;) ProFisheryObj2@title&lt;-&quot;FisheryArea2&quot; ProFisheryObj2@vulType&lt;-&quot;logistic&quot; ProFisheryObj2@vulParams&lt;-c(10.2,0.1) ProFisheryObj2@retType&lt;-&quot;full&quot; ProFisheryObj2@retMax &lt;- 1 ProFisheryObj2@Dmort &lt;- 0 ProFisheryObj_list = list(ProFisheryObj1, ProFisheryObj2) 5.2.2 Uncertainty in the projection fishery Additional slots in the StochasticObj object allow for modifications to the fishery projection object. These additional slots, StochasticObj@proFisheryVul_list, StochasticObj@proFisheryRet_list, and StochasticObj@proFisheryDmort_list, are lists where the number of list items corresponds to the number of areas (TimeAreaObj@areas). Each item in the list is a matrix with \\(n\\) columns and 2 rows, where the rows represent the minimum and maximum values for the parameters associated with each column \\(n\\). When provided, these lists replace the vulParams, retParams, and Dmort slots in the corresponding items in ProFisheryObj_list (see spatial considerations, above). For StochasticObj@proFisheryVul_list and StochasticObj@proFisheryRet_list, the number of columns in the matrix align with the required inputs for ProFisheryObj@vulType and ProFisheryObj@retType. During each iteration, the model samples values from a uniform distribution within the specified range (i.e., between the min and max values defined in the rows), allowing for uncertainty in the parameters, independently for each area. The final slots in the StochasticObj object are StochasticObj@sameFisheryVul, StochasticObj@sameFisheryRet, and StochasticObj@sameFisheryDmort. Each slot contains a logical variable (“TRUE” or “FALSE”). If set to TRUE, arguments of StochasticObj that replace arguments of the HistFisheryObj will also replace arguments of the ProFisheryObj_list. This option is provided so that, for a given iteration, identical samples values from the corresponding uniform distribution will be applied to both the historical and projection time periods. When StochasticObj@sameFisheryVul = TRUE, values generated for StochasticObj@histFisheryVul will be applied so that historical and projection parameter values are identical. TRUE also overrides any input in StochasticObj@proFisheryVul_list When StochasticObj@sameFisheryRet = TRUE, values generated for StochasticObj@histFisheryRet will be applied so that historical and projection parameter values are identical. TRUE also overrides any input in StochasticObj@proFisheryRet_list When StochasticObj@sameFisheryDmort = TRUE, values generated for StochasticObj@histFisheryDmort will be applied so that historical and projection parameter values are identical. TRUE also overrides any input in StochasticObj@proFisheryDmort_list 5.3 MP Template FishSimGTG provides a framework for users to construct custom MPs. A StrategyObj defines a general set of instructions about the MP, including the slot StrategyObj@projectionName that holds the name of the MP. To develop an MP, the user must populate a function with the same name with an algorithm describing how the fishery will be managed. The MP function must adhere to the template structure described in the next section. The template structure ensures that the MP can integrated into the management strategy evaluation modeling process. StrategyObj&lt;-new(&quot;Strategy&quot;) StrategyObj@title = &quot;Example&quot; StrategyObj@projectionYears = 25 StrategyObj@projectionName = &quot;MP1&quot; #Must correspond to a named function When a new strategy object StrategyObj is created, the function named in the slot StrategyObj@projectionName can be specified using the following template: templateMP &lt;- function(phase, dataObject) { #------------------------------------ #Unpacking: required - do not delete #------------------------------------ #Unpack dataObject - objects passed from the OM to the MP for(r in 1:NROW(dataObject)) assign(names(dataObject)[r], dataObject[[r]]) #------------------------------------------ #Book keeping - be aware of year j indexing! #------------------------------------------ #OM years are indexed 1:(1 + TimeAreaObj@historicalYears + StrategyObj@projectionYears) #Indexes specified within Class Strategy are typically indexed 1:projectionYears #To obtain the current projection year: yr &lt;- j - TimeAreaObj@historicalYears - 1 #To obtain the terminal year of the historical period yrHist &lt;- TimeAreaObj@historicalYears + 1 #----------------------------------------------------------------- #Summary of all available objects unpacked and passed from the OM #----------------------------------------------------------------- #j, current time step in OM #k, current iteration in OM #is, initial stock (equilibrium) for iteration k, year 1, contains values returned by solveD #lh, LHwrapper object for iteration k, contains values returned by LHwrapper #areas, contains TimeAreaObj@areas #ageClasses, contains the number of age classes. Obtained from lh$ageClasses. Caution: age 0 is always the first age class. #N, abundance-at-age for iteration k. A list of length lh$gtg that contains elements array(dim=c(ageClasses, years, areas)) #selGroup, selectivity for iteration k and step j. A list of length areas with elements contains values returned by selWrapper #selHist, selectivity for iteration k for historical time period. A list of length areas with elements contains values returned by selWrapper #selPro, selectivity for iteration k for projection time period. A list of length areas with elements contains values returned by selWrapper #SB, spawing biomass at the beginnning of the year, array(dim=c(years, iterations, areas)) #VB, vulnerable biomass at the beginning of the year, array(dim=c(years, iterations, areas)) #RB, retained biomass at the beginning of the year, array(dim=c(years, iterations, areas)) #catchN, annual catch in numbers in aggregate across gtg, array(dim=c(years, iterations, areas)) #catchB, annual catch in biomass in aggregate across gtg, array(dim=c(years, iterations, areas)) #discN, dead discards in numbers in aggregate across gtg, array(dim=c(years, iterations, areas)) #discB, dead discards in biomass in aggregate across gtg, array(dim=c(years, iterations, areas)) #Ftotal, fishing mortality rate, array(dim=c(years, iterations, areas)) #SPR, spawning potential ratio, for entire population, array(dim=c(years, iterations)) #relB, relative spawning biomass (depletion) for entire population, array(dim=c(years, iterations)) #recN, annual age-0 recruitment in numbers, array(dim=c(years, iterations)) #decisionData, optional data frame containing annual sampling details. (see phase 1 below) #decisionAnnual, optional data frame containing analysis and HCR info (see phase 2 below) #decisionLocal, mandatory data frame containing fishing mortality by area for year j and iteration k, (see phase 3 below) #RdevMatrix, recruitment deviations, contains values returned by recDev #Ddev, initial relative biomass deviations, contains values returned by bioDev #TimeAreaObj #StrategyObj #-------------------------------------- #Phases of an MP #-------------------------------------- #An MP can have up to 3 phases. Phase 3 is mandatory, phases 1 &amp; 2 are optional #The OM will call this MP 3 times in each time step: #Phase 1: Observation model or simulated sampling/observations of the OM. #Phase 2: Analysis and harvest control rule #Phase 3: Calculate fishing mortality to be passed back to the OM. ######## #Phase 1 - OPTIONAL. Observation process in year j #Phase 1 is called by the OM once for each iteration, k, and year, j. #Used to define imperfect sampling in year j #Returned list is appended to data frame: decisionData if(phase==1){ #User defines computations needed. #User defines variable names for returned list, as this info will be used in Phase 2 (HCR) return(list()) #e.g., return(list(year = j, iteration = k, CPUE = 1.4)) } ######## #Phase 2 - OPTIONAL. Analysis, decision-rule and/or HCR #Phase 2 is called by the OM once for each iteration, k, and year, j. #Used to define how catches will be regulated #Returned list is appended to data frame: decisionAnnual if(phase==2){ #User defines computations needed (likely will rely on info saved to decisionData) #User defines variable names for returned list, as this info will be used in Phase 3 return(list()) #e.g., return(list(year = j, iteration = k, TAC = 1400)) } ######## #Phase 3 - MANDATORY. Calculation of fishing mortality to be used by the OM #Phase 3 is called by the OM once for each iteration, k, and year, j. #Used to compute fishing mortality for the called k and j. #Returned list is appended to data frame: decisionLocal and retrieved by OM to calcualte catchN, catchB, etc. if(phase==3){ #Must contain these elements, each a vector of length areas: year = rep(j, areas) #Time step to which fishing mortality applies iteration = rep(k, areas) #Iteration to which fishing mortality applies area = 1:areas #Area to which fishing mortality applies Flocal = rep(0.2, areas) #Calculation of fishing mortality (typically a complex computation is needed, e.g., to covert TAC to F) #Must return this list structure: return(list(year=year, iteration=iteration, area=area, Flocal=Flocal)) } } 5.4 MP library "],["mse.html", "6 Management strategy evaluation", " 6 Management strategy evaluation Coming soon….. "],["measuring-performance.html", "7 Measuring performance", " 7 Measuring performance Coming soon… "],["examples.html", "8 Examples 8.1 Projection modeling", " 8 Examples 8.1 Projection modeling This example demonstrates implementation of Projection Modeling. Projection modeling differs from an MP in that projections consist of ‘static’ actions such as a size limit or constant fishing effort, whereas MPs are ‘dynamic’ responses to updated information (e.g., pre-agreed responses to observations of the fishery system). While making such projections are strictly speaking not the same MPs, setting up projection modeling follows the same coding in FishSimGTG and relies on specification of a StrategyObj. Below, a complex OM is defined with three areas. Projection modeling is used to evaluate a suite of management options, including size limits, effort reductions (such as seasonal closures or time-day closures). All projections are developed under the assumption that fishing effort is re-allocated from closed areas to open areas, rather than being removed from the fishery. 8.1.1 Populate the life history object See Section 3 for details on how to populate the Operating Model. # Load necessary package library(fishSimGTG) library(fishSimTools) LifeHistoryObj &lt;- new(&quot;LifeHistory&quot;) LifeHistoryObj@title&lt;-&quot;Honeycomb grouper&quot; LifeHistoryObj@speciesName&lt;-&quot;EpinephelusMerra&quot; LifeHistoryObj@shortDescription&lt;-&quot;example multiple areas&quot; LifeHistoryObj@Linf&lt;-24.4 LifeHistoryObj@K&lt;-0.2 LifeHistoryObj@t0&lt;- 0 LifeHistoryObj@L50&lt;-14.1 LifeHistoryObj@L95delta&lt;-2.1 LifeHistoryObj@M&lt;-0.29 LifeHistoryObj@L_type&lt;-&quot;FL&quot; LifeHistoryObj@L_units&lt;-&quot;cm&quot; LifeHistoryObj@LW_A&lt;-0.016 LifeHistoryObj@LW_B&lt;-2.966 LifeHistoryObj@Walpha_units&lt;-&quot;g&quot; LifeHistoryObj@Steep&lt;-0.69 LifeHistoryObj@recSD&lt;-0.6 LifeHistoryObj@recRho&lt;-0 LifeHistoryObj@isHermaph&lt;-FALSE #ignored for demo purposes LifeHistoryObj@R0&lt;-10000 8.1.2 Populate the historical fishery object This structure assumes a fishery operating during the historical time with same fishery characteristics in each area. HistFisheryObj&lt;-new(&quot;Fishery&quot;) HistFisheryObj@title&lt;-&quot;Test&quot; HistFisheryObj@vulType&lt;-&quot;logistic&quot; HistFisheryObj@vulParams&lt;-c(12, 1) HistFisheryObj@retType&lt;-&quot;full&quot; HistFisheryObj@retMax &lt;- 1 HistFisheryObj@Dmort &lt;- 0 8.1.3 Populate the time-area object The three areas are specified to recieve approximately equal numbers of recruits. The historical dynamics are simulated to reflect an initial depletion level of 0.5, followed by a stable level of fishing effort for 10 years. # I want to run the low movement scenario TimeAreaObj&lt;-new(&quot;TimeArea&quot;) TimeAreaObj@title &lt;- &quot;Test&quot; TimeAreaObj@gtg &lt;- 13 TimeAreaObj@areas &lt;- 3 TimeAreaObj@recArea &lt;- c(0.33, 0.33,0.34) TimeAreaObj@iterations &lt;- 100 TimeAreaObj@historicalYears &lt;- 10 TimeAreaObj@historicalBio &lt;- 0.5 TimeAreaObj@historicalBioType &lt;- &quot;relB&quot; TimeAreaObj@move &lt;- matrix(c( 0.9, 0.05, 0.05, 0.05, 0.9, 0.05, 0.05, 0.05, 0.9), nrow=3, ncol=3, byrow=TRUE) TimeAreaObj@historicalEffort &lt;- matrix(1:1, nrow = 50, ncol = 3, byrow = FALSE) The slot TimeAreaObj@move defines the proportion of abundance migrating to other areas. Columns are ‘from area’ and rows are ‘to area’. #E.g. A two-area model: # [,1] [,2] # [1,] Area 1 staying in 1 Area 2 going to 1 # [,2] Area 1 going to 2 Area 2 statying in 2 #To specify no movement in a two-area model, use: matrix(c(1,0, 0,1), nrow=2, ncol=2, byrow=FALSE) ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 In the current example, 90% of individuals do not change areas annually, with 5% going to each of the other two adjacent areas. #In our current example: TimeAreaObj@move ## [,1] [,2] [,3] ## [1,] 0.90 0.05 0.05 ## [2,] 0.05 0.90 0.05 ## [3,] 0.05 0.05 0.90 8.1.4 Review life history characteristics #To simply display to the console lhOut &lt;- LHwrapper(LifeHistoryObj, TimeAreaObj, doPlot = TRUE) Figure 8.1: Life history schedules of honeycomb grouper. #To return life history details lhOut 8.1.5 Review fishery characteristics selOut &lt;- selWrapper(lh = lhOut, TimeAreaObj, FisheryObj = HistFisheryObj, doPlot = TRUE) Figure 8.2: Logistic selectivity function. 8.1.6 Include uncertainty In this example, uniform distributions are specified to reflect uncertainty in life history and historical fishery vulnerability. StochasticObj&lt;-new(&quot;Stochastic&quot;) StochasticObj@historicalBio &lt;- c(0.2, 0.6) StochasticObj@Linf &lt;- c(24.4, 29.8) StochasticObj@K &lt;- c(0.2, 0.97) StochasticObj@L50 &lt;- c(14.1, 16.8) StochasticObj@L95delta &lt;- c(2.1, 2.5) StochasticObj@M &lt;- c(0.29, 0.43) StochasticObj@Steep &lt;- c(0.69, 0.84) StochasticObj@histFisheryVul &lt;- matrix(c(10,14,0.5,1), nrow=2, ncol=2,byrow=FALSE) StochasticObj@sameFisheryVul &lt;- TRUE In the HistFisheryObj, HistFisheryObj@vulType&lt;-\"logistic\", thus requiring two input parameters to describe the logistic vulnerability function. To introduce uncertainty into these two parameters, a 2 x 2 matrix is required with columns reflecting number of parameters and rows representing minimum and maximum values for each parameter. StochasticObj@histFisheryVul ## [,1] [,2] ## [1,] 10 0.5 ## [2,] 14 1.0 8.1.7 Specify projection conditions Like defining an MP, projection modeling requires two additional S4 objects are needed: ProFisheryObj and StrategyObj. The forward projection fishery object is specified to implement a size limit of 14 cm (see ProFisheryObj@retType and ProFisheryObj@retParams). Notice that StochasticObj@sameFisheryVul=TRUE, so the uncertainty range for vulnerability in the historical time period will also be applied to the projection time period, ignoring ProFisheryObj@vulType and ProFisheryObj@vulParams. Thus, in this example, fishery selectivity is consistent between historical and projection time periods, but a size limit is implemented by modifying retention (and correspondingly assuming discard mortality is zero ProFisheryObj@Dmort &lt;- 0). ProFisheryObj &lt;- new(&quot;Fishery&quot;) ProFisheryObj@title &lt;- &quot;Test&quot; ProFisheryObj@vulType &lt;- &quot;logistic&quot; ProFisheryObj@vulParams &lt;- c(12, 1) ProFisheryObj@retType &lt;- &quot;logistic&quot; ProFisheryObj@retParams &lt;- c(14, 0.1) ProFisheryObj@retMax &lt;- 1 ProFisheryObj@Dmort &lt;- 0 #Finally, we need to define fishery characteristics for each area in the OM. #In this case, we will assume each area has the same fishery characteristics ProFisheryObj_list &lt;- list(ProFisheryObj, ProFisheryObj, ProFisheryObj) The second additional object is the StrategyObj. The built in MP named projectionStrategy contains a variety of controls of static changes to fishery management, including control of fishing effort. The strategy considered is to close one area permanently and assume effort from the closed area will be dispersed equally to the remain two areas. See MP library in section 5.4 for details StrategyObj&lt;-new(&quot;Strategy&quot;) StrategyObj@projectionYears &lt;- 25 StrategyObj@projectionName&lt;-&quot;projectionStrategy&quot; StrategyObj@projectionParams&lt;-list( bag = c(-99 -99 -99), effort = c(rep(1.5, 25), rep(0, 25), rep(1.5, 25)) ) 8.1.8 Running projections runProjection( LifeHistoryObj = LifeHistoryObj, TimeAreaObj = TimeAreaObj, HistFisheryObj = HistFisheryObj, ProFisheryObj_list = ProFisheryObj_list, StrategyObj = StrategyObj, StochasticObj = StochasticObj, wd = here(&quot;data-test&quot;, &quot;Kole&quot;), fileName = &quot;Size_option1&quot;, doPlot = TRUE, titleStrategy = &quot;Min size 14 cm&quot; ) Next, we present some of the diagnostic plots produced by runProjection(). 8.1.9 Simple batch processing "],["references.html", "References", " References Beverton, R. J. H., and S. J. Holt. 1957. On the Dynamics of Exploited Fish Populations. London: Her Majesty’s Stationery Office. Hordyk, Adrian R., Kotaro Ono, Jeremy D. Prince, and Carl J. Walters. 2016. “A Simple Length-Structured Model Based on Life History Ratios and Incorporating Size-Dependent Selectivity: Application to Spawning Potential Ratios for Data-Poor Stocks.” Canadian Journal of Fisheries and Aquatic Sciences 73 (12): 1787–99. https://doi.org/10.1139/cjfas-2015-0422. Pine III, William E, Carl J Walters, Edward V Camp, Rachel Bouchillon, Robert Ahrens, Leslie Sturmer, and Mark E Berrigan. 2015. “The Curious Case of Eastern Oyster Crassostrea Virginica Stock Status in Apalachicola Bay, Florida.” Ecology and Society 20 (3). Punt, André E., Doug S. Butterworth, Carryn L. de Moor, José A. A. De Oliveira, and Malcolm Haddon. 2016. “Management Strategy Evaluation: Best Practices.” Fish and Fisheries 17 (2): 303–34. https://doi.org/10.1111/faf.12104. Quinn, Terrance J, and Richard B Deriso. 1999. Quantitative Fish Dynamics. oxford university Press. R Core Team. 2022. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Walters, Carl J, and Steven JD Martell. 2004. Fisheries Ecology and Management. Princeton University Press. "]]
